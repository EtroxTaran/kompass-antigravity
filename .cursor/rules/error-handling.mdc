---
description: Structured error responses (RFC 7807), global exception filters, domain-specific exceptions, structured logging, correlation IDs, and secure error handling patterns
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---

# Error Handling & Logging

## Error Handling Patterns

### Structured Error Responses

ALWAYS return consistent error responses (RFC 7807):

```typescript
// ✅ CORRECT: Structured error response
interface ProblemDetails {
  type: string;
  title: string;
  status: number;
  detail?: string;
  instance?: string;
  errors?: ValidationError[];
}

// Example error response
{
  "type": "https://api.kompass.de/errors/validation-error",
  "title": "Validation Failed",
  "status": 400,
  "detail": "Company name must be 2-200 characters",
  "instance": "/api/v1/customers",
  "errors": [
    {
      "field": "companyName",
      "message": "Company name must be 2-200 characters",
      "value": "A"
    }
  ]
}
```

### Global Exception Filter

ALWAYS use global exception filter:

```typescript
// ✅ CORRECT: Global exception filter
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    const message = exception instanceof HttpException
      ? exception.getResponse()
      : 'Internal server error';

    // Log full error server-side
    this.logger.error({
      message: exception instanceof Error ? exception.message : 'Unknown error',
      stack: exception instanceof Error ? exception.stack : undefined,
      url: request.url,
      method: request.method,
      userId: request.user?.id,
    });

    // Return sanitized error to client
    response.status(status).json({
      type: 'https://api.kompass.de/errors/server-error',
      title: 'An error occurred',
      status,
      detail: process.env.NODE_ENV === 'production'
        ? 'An error occurred' // Generic in production
        : message,
      instance: request.url,
      timestamp: new Date().toISOString(),
    });
  }
}
```

### Domain-Specific Exceptions

Use domain-specific exception classes:

```typescript
// ✅ CORRECT: Domain-specific exceptions
export class DomainException extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number = 500
  ) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class NotFoundException extends DomainException {
  constructor(entity: string, id: string) {
    super(`${entity} with ID ${id} not found`, 'NOT_FOUND', 404);
  }
}

export class ValidationException extends DomainException {
  constructor(
    message: string,
    public readonly errors: ValidationError[]
  ) {
    super(message, 'VALIDATION_ERROR', 400);
  }
}

export class ForbiddenException extends DomainException {
  constructor(message: string) {
    super(message, 'FORBIDDEN', 403);
  }
}
```

## Logging Patterns

### Structured Logging

ALWAYS use structured logging:

```typescript
// ✅ CORRECT: Structured logging
import { Logger } from '@nestjs/common';

const logger = new Logger('CustomerService');

logger.log('Customer created', {
  customerId: customer.id,
  userId: user.id,
  timestamp: new Date().toISOString(),
  requestId: request.id,
});

logger.error('Failed to create customer', {
  error: error.message,
  stack: error.stack,
  userId: user.id,
  requestId: request.id,
});
```

### Log Levels

Use appropriate log levels:

- **DEBUG**: Detailed information for debugging (development only)
- **INFO**: General informational messages (user login, object created)
- **WARN**: Warning messages (config not found, permission denied)
- **ERROR**: Error messages that need attention

```typescript
// ✅ CORRECT: Appropriate log levels
logger.debug('Processing customer data', { customerId }); // Dev only
logger.info('Customer created successfully', { customerId });
logger.warn('Customer quota exceeded', { customerId, quota: 100 });
logger.error('Failed to save customer', { error, customerId });
```

### Never Log Sensitive Data

```typescript
// ✅ CORRECT: Sanitized logging
logger.log('User login', {
  userId: user.id,
  email: user.email, // OK - email is not sensitive
  // DO NOT log: password, tokens, credit card numbers, SSN
});

// ❌ WRONG: Logging sensitive data
logger.log('Login attempt', {
  password: dto.password, // NEVER!
  jwtToken: token, // NEVER!
  creditCard: cardNumber, // NEVER!
});
```

### Correlation IDs

ALWAYS include correlation IDs in logs:

```typescript
// ✅ CORRECT: Correlation ID middleware
@Injectable()
export class CorrelationIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    const correlationId = req.headers['x-correlation-id'] || uuidv4();
    req['correlationId'] = correlationId;
    res.setHeader('X-Correlation-ID', correlationId);
    next();
  }
}

// Use in logging
logger.log('Request processed', {
  correlationId: request['correlationId'],
  method: request.method,
  url: request.url,
});
```

## Frontend Error Handling

### Error Boundaries

ALWAYS use error boundaries in React:

```typescript
// ✅ CORRECT: Error boundary
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error, resetErrorBoundary }: ErrorFallbackProps) {
  return (
    <div role="alert">
      <h2>Something went wrong</h2>
      <pre>{error.message}</pre>
      <Button onClick={resetErrorBoundary}>Try again</Button>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <Routes>
        {/* Routes */}
      </Routes>
    </ErrorBoundary>
  );
}
```

### API Error Handling

```typescript
// ✅ CORRECT: API error handling
import { useQuery, useMutation } from '@tanstack/react-query';
import { toast } from '@/hooks/use-toast';

export function useCustomer(id: string) {
  return useQuery({
    queryKey: ['customer', id],
    queryFn: () => customerApi.getById(id),
    onError: (error: ApiError) => {
      toast({
        title: 'Error',
        description: error.message || 'Failed to load customer',
        variant: 'destructive',
      });
    },
  });
}
```

## References

- NestJS Exception Filters: https://docs.nestjs.com/exception-filters
- React Error Boundaries: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary
