---
description: Test coverage requirements (80% overall, 90% business logic), 70/20/10 test pyramid (Unit/Integration/E2E), test file locations, structure examples, and mocking rules
globs: ["**/*.spec.ts", "**/*.spec.tsx", "**/*.test.ts", "**/*.test.tsx", "**/*.e2e.spec.ts"]
alwaysApply: true
---

# Testing Strategy (70/20/10 Pyramid)

## Test Coverage Requirements

### Coverage Targets

- **Overall**: 80% minimum
- **Business logic (services)**: 90% minimum
- **React components**: 80% minimum
- **Utilities**: 85% minimum
- **Controllers/routes**: 70% minimum

### Coverage Enforcement

```typescript
// jest.config.js
module.exports = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
    './apps/backend/src/modules/*/services/*.ts': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90,
    },
    './apps/frontend/src/**/*.tsx': {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
    './packages/shared/src/**/*.ts': {
      branches: 85,
      functions: 85,
      lines: 85,
      statements: 85,
    },
  },
};
```

## Test Pyramid Distribution

### 70% Unit Tests

Fast, isolated tests for individual functions, methods, and components.

### 20% Integration Tests

Tests that verify interactions between modules, services, and external systems.

### 10% E2E Tests

End-to-end tests that verify complete user workflows.

## Unit Tests (70% of tests)

### Test File Location

Unit tests MUST be colocated with source files:

```
apps/backend/src/modules/customer/
├── customer.service.ts
├── customer.service.spec.ts          ✅ Colocated
├── customer.controller.ts
└── customer.controller.spec.ts       ✅ Colocated

apps/frontend/src/features/customer/components/
├── CustomerList.tsx
└── CustomerList.spec.tsx             ✅ Colocated
```

### Unit Test Structure

```typescript
// ✅ CORRECT: Well-structured unit test
import { Test } from '@nestjs/testing';
import { CustomerService } from './customer.service';
import { ICustomerRepository } from './customer.repository.interface';
import { NotFoundException, ValidationException } from '@kompass/shared/exceptions';

describe('CustomerService', () => {
  let service: CustomerService;
  let repository: jest.Mocked<ICustomerRepository>;

  beforeEach(async () => {
    // Mock repository
    repository = {
      findById: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    } as any;

    const module = await Test.createTestingModule({
      providers: [
        CustomerService,
        {
          provide: 'ICustomerRepository',
          useValue: repository,
        },
      ],
    }).compile();

    service = module.get<CustomerService>(CustomerService);
  });

  describe('findById', () => {
    it('should return customer when found', async () => {
      const mockCustomer = { id: '1', companyName: 'Test GmbH' };
      repository.findById.mockResolvedValue(mockCustomer);

      const result = await service.findById('1');

      expect(result).toEqual(mockCustomer);
      expect(repository.findById).toHaveBeenCalledWith('1');
    });

    it('should throw NotFoundException when not found', async () => {
      repository.findById.mockResolvedValue(null);

      await expect(service.findById('999')).rejects.toThrow(NotFoundException);
    });
  });

  describe('create', () => {
    it('should validate company name length', async () => {
      const invalidCustomer = { companyName: 'A' }; // Too short

      await expect(service.create(invalidCustomer)).rejects.toThrow(ValidationException);
    });

    it('should validate VAT number format', async () => {
      const invalidCustomer = { 
        companyName: 'Test GmbH',
        vatNumber: 'INVALID' // Wrong format
      };

      await expect(service.create(invalidCustomer)).rejects.toThrow(ValidationException);
    });
  });
});
```

### Frontend Unit Test Example

```typescript
// ✅ CORRECT: React component unit test
import { render, screen, fireEvent } from '@testing-library/react';
import { CustomerCard } from './CustomerCard';

describe('CustomerCard', () => {
  const mockCustomer = {
    id: 'customer-123',
    companyName: 'Test GmbH',
    vatNumber: 'DE123456789',
    address: { city: 'München' },
  };

  it('should render customer information', () => {
    render(<CustomerCard customer={mockCustomer} />);
    
    expect(screen.getByText('Test GmbH')).toBeInTheDocument();
    expect(screen.getByText('DE123456789')).toBeInTheDocument();
    expect(screen.getByText('München')).toBeInTheDocument();
  });

  it('should call onSelect when clicked', () => {
    const onSelect = jest.fn();
    render(<CustomerCard customer={mockCustomer} onSelect={onSelect} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(onSelect).toHaveBeenCalledWith('customer-123');
  });
});
```

## Integration Tests (20% of tests)

### Integration Test Location

```
tests/integration/
├── customer/
│   ├── customer-api.integration.spec.ts
│   └── customer-repository.integration.spec.ts
└── opportunity/
    └── opportunity-api.integration.spec.ts
```

### Integration Test Example

```typescript
// ✅ CORRECT: Integration test with real database
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../../src/app.module';

describe('Customer API (Integration)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // Get auth token
    const loginResponse = await request(app.getHttpServer())
      .post('/auth/login')
      .send({ email: 'test@example.com', password: 'test123' });
    authToken = loginResponse.body.token;
  });

  afterAll(async () => {
    await app.close();
  });

  describe('POST /api/v1/customers', () => {
    it('should create customer with valid data', async () => {
      const newCustomer = {
        companyName: 'Test GmbH',
        vatNumber: 'DE123456789',
        address: {
          street: 'Teststraße 1',
          zipCode: '80331',
          city: 'München',
          country: 'Deutschland',
        },
      };

      const response = await request(app.getHttpServer())
        .post('/api/v1/customers')
        .set('Authorization', `Bearer ${authToken}`)
        .send(newCustomer)
        .expect(201);

      expect(response.body).toMatchObject({
        id: expect.any(String),
        companyName: 'Test GmbH',
        vatNumber: 'DE123456789',
      });
    });

    it('should return 401 without auth token', async () => {
      await request(app.getHttpServer())
        .post('/api/v1/customers')
        .send({ companyName: 'Test' })
        .expect(401);
    });
  });
});
```

## E2E Tests (10% of tests)

### E2E Test Location

```
tests/e2e/
├── customer/
│   ├── create-customer.spec.ts
│   ├── search-customer.spec.ts
│   └── duplicate-detection.spec.ts
└── offline/
    ├── offline-create.spec.ts
    └── conflict-resolution.spec.ts
```

### E2E Test with Playwright

```typescript
// ✅ CORRECT: Playwright E2E test
import { test, expect } from '@playwright/test';

test.describe('Customer Management', () => {
  test('should create new customer', async ({ page }) => {
    // Login
    await page.goto('/login');
    await page.fill('[name="email"]', 'adm@example.com');
    await page.fill('[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // Navigate to customers
    await page.goto('/customers');
    await expect(page.locator('h1')).toContainText('Customers');

    // Create new customer
    await page.click('button:has-text("New Customer")');
    await page.fill('[name="companyName"]', 'Test Hofladen GmbH');
    await page.fill('[name="vatNumber"]', 'DE123456789');
    await page.fill('[name="address.street"]', 'Hauptstraße 15');
    await page.fill('[name="address.zipCode"]', '80331');
    await page.fill('[name="address.city"]', 'München');
    await page.fill('[name="phone"]', '+49-89-1234567');
    await page.fill('[name="email"]', 'info@testhofladen.de');

    await page.click('button:has-text("Save")');

    // Verify success
    await expect(page.locator('.toast-success')).toContainText('Customer created');
    await expect(page.locator('h1')).toContainText('Test Hofladen GmbH');
  });

  test('should detect duplicate customers', async ({ page }) => {
    // Test duplicate detection workflow
    await page.goto('/customers');
    await page.click('button:has-text("New Customer")');
    await page.fill('[name="companyName"]', 'Existing Customer GmbH');
    await page.fill('[name="vatNumber"]', 'DE999999999');
    await page.click('button:has-text("Save")');

    // Should show duplicate warning
    await expect(page.locator('.toast-warning')).toContainText('Duplicate detected');
  });
});
```

## Test Naming Conventions

### ✅ CORRECT: Descriptive Test Names

```typescript
describe('CustomerService', () => {
  describe('findById', () => {
    it('should return customer when found', async () => {});
    it('should throw NotFoundException when not found', async () => {});
    it('should filter fields based on user role', async () => {});
  });

  describe('create', () => {
    it('should validate company name length', async () => {});
    it('should validate VAT number format', async () => {});
    it('should set owner to current user', async () => {});
  });
});
```

### ❌ WRONG: Vague Test Names

```typescript
describe('CustomerService', () => {
  it('test1', async () => {}); // What does this test?
  it('works', async () => {}); // What works?
  it('should work', async () => {}); // Too vague
});
```

## Mocking Rules

### What to Mock

- External services (CouchDB, MeiliSearch, Keycloak, n8n)
- HTTP requests (use MSW or nock)
- Date/time functions (use `jest.useFakeTimers()`)
- File system operations
- Environment variables

```typescript
// ✅ CORRECT: Mocking external service
jest.mock('@kompass/shared/services/meilisearch', () => ({
  searchCustomers: jest.fn(),
}));

// ✅ CORRECT: Mocking date/time
beforeEach(() => {
  jest.useFakeTimers();
  jest.setSystemTime(new Date('2024-01-01'));
});

afterEach(() => {
  jest.useRealTimers();
});
```

### What NOT to Mock

- Pure functions
- Simple utilities
- The code under test itself
- Shared validation functions

```typescript
// ❌ WRONG: Mocking pure function
jest.mock('@kompass/shared/utils/format-currency', () => ({
  formatCurrency: jest.fn(),
}));

// ✅ CORRECT: Test pure function directly
import { formatCurrency } from '@kompass/shared/utils/format-currency';

it('should format currency correctly', () => {
  expect(formatCurrency(1000)).toBe('1.000,00 €');
});
```

## Test Organization

### Test Structure

1. **Arrange**: Set up test data and mocks
2. **Act**: Execute the code under test
3. **Assert**: Verify the results

```typescript
it('should calculate total correctly', () => {
  // Arrange
  const lineItems = [
    { quantity: 2, price: 10 },
    { quantity: 3, price: 20 },
  ];

  // Act
  const total = calculateTotal(lineItems);

  // Assert
  expect(total).toBe(80);
});
```

## Running Tests

### Test Commands

```bash
# Run all tests
pnpm test

# Run unit tests only
pnpm test:unit

# Run integration tests only
pnpm test:integration

# Run E2E tests only
pnpm test:e2e

# Run tests with coverage
pnpm test:coverage

# Run tests in watch mode
pnpm test:watch
```

## Frontend Testing Patterns

### Component Testing with React Testing Library

ALWAYS use React Testing Library for component tests. Focus on testing user behavior, not implementation details.

```typescript
// ✅ CORRECT: Testing user interactions
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { CustomerForm } from './CustomerForm';

describe('CustomerForm', () => {
  it('should submit form with valid data', async () => {
    const onSubmit = vi.fn();
    render(<CustomerForm onSubmit={onSubmit} />);

    // Fill form fields
    await fireEvent.change(screen.getByLabelText('Company Name'), {
      target: { value: 'Test GmbH' },
    });
    await fireEvent.change(screen.getByLabelText('VAT Number'), {
      target: { value: 'DE123456789' },
    });

    // Submit form
    await fireEvent.click(screen.getByRole('button', { name: 'Save' }));

    // Verify submission
    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith({
        companyName: 'Test GmbH',
        vatNumber: 'DE123456789',
      });
    });
  });

  it('should display validation errors', async () => {
    render(<CustomerForm />);

    // Submit empty form
    await fireEvent.click(screen.getByRole('button', { name: 'Save' }));

    // Verify error messages
    await waitFor(() => {
      expect(screen.getByText('Company name is required')).toBeInTheDocument();
    });
  });
});
```

### Testing Accessibility

ALWAYS test accessibility requirements (WCAG 2.1 AA):

```typescript
// ✅ CORRECT: Testing accessibility with React Testing Library
import { render, screen, fireEvent } from '@testing-library/react';
import { axe } from 'vitest-axe';
import { expect, test } from 'vitest';

test('should have no accessibility violations', async () => {
  const { container } = render(<CustomerCard customer={mockCustomer} />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});

test('should be keyboard navigable', () => {
  const onSelect = vi.fn();
  render(<CustomerCard customer={mockCustomer} onSelect={onSelect} />);

  // Tab to button
  screen.getByRole('button').focus();
  expect(screen.getByRole('button')).toHaveFocus();

  // Press Enter to activate
  fireEvent.keyDown(screen.getByRole('button'), { key: 'Enter', code: 'Enter' });
  expect(onSelect).toHaveBeenCalled();
});

test('should have proper ARIA labels', () => {
  render(<CustomerCard customer={mockCustomer} />);
  expect(screen.getByLabelText('Customer card: Test GmbH')).toBeInTheDocument();
});
```

### Testing Loading and Error States

ALWAYS test loading and error states:

```typescript
// ✅ CORRECT: Testing loading and error states
describe('CustomerList', () => {
  it('should display loading skeleton', () => {
    render(<CustomerList isLoading={true} customers={[]} />);
    expect(screen.getAllByTestId('customer-skeleton')).toHaveLength(3);
  });

  it('should display error message', () => {
    render(<CustomerList error={new Error('Failed to load')} customers={[]} />);
    expect(screen.getByText('Failed to load customers')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Retry' })).toBeInTheDocument();
  });

  it('should display empty state', () => {
    render(<CustomerList customers={[]} />);
    expect(screen.getByText('No customers found')).toBeInTheDocument();
  });
});
```

### Testing Responsive Behavior

Test responsive behavior with viewport changes:

```typescript
// ✅ CORRECT: Testing responsive behavior
import { render, screen } from '@testing-library/react';

describe('CustomerList Responsive', () => {
  it('should show mobile layout on small screens', () => {
    window.innerWidth = 375;
    window.dispatchEvent(new Event('resize'));

    render(<CustomerList customers={mockCustomers} />);
    expect(screen.getByTestId('mobile-customer-list')).toBeInTheDocument();
  });

  it('should show desktop layout on large screens', () => {
    window.innerWidth = 1920;
    window.dispatchEvent(new Event('resize'));

    render(<CustomerList customers={mockCustomers} />);
    expect(screen.getByTestId('desktop-customer-list')).toBeInTheDocument();
  });
});
```

### Hook Testing Patterns

Test custom hooks using `@testing-library/react-hooks` or `renderHook`:

```typescript
// ✅ CORRECT: Testing custom hooks
import { renderHook, waitFor } from '@testing-library/react';
import { useCustomer } from './useCustomer';

describe('useCustomer', () => {
  it('should fetch customer data', async () => {
    const { result } = renderHook(() => useCustomer('customer-123'));

    expect(result.current.isLoading).toBe(true);
    expect(result.current.customer).toBeNull();

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.customer).toMatchObject({
      id: 'customer-123',
      companyName: 'Test GmbH',
    });
  });

  it('should handle errors', async () => {
    vi.spyOn(customerApi, 'getById').mockRejectedValue(new Error('Not found'));

    const { result } = renderHook(() => useCustomer('invalid-id'));

    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
    });

    expect(result.current.error?.message).toBe('Not found');
  });
});
```

### Visual Regression Testing

Use Playwright visual comparisons for visual regression testing:

```typescript
// ✅ CORRECT: Visual regression test with Playwright
import { test, expect } from '@playwright/test';

test('customer form visual regression', async ({ page }) => {
  await page.goto('/customers/new');
  
  // Take screenshot and compare
  await expect(page).toHaveScreenshot('customer-form.png', {
    fullPage: true,
    threshold: 0.2, // 20% pixel difference tolerance
  });
});

test('customer card hover state', async ({ page }) => {
  await page.goto('/customers');
  const card = page.locator('[data-testid="customer-card"]').first();
  
  await card.hover();
  await expect(card).toHaveScreenshot('customer-card-hover.png');
});
```

### Cross-Browser Testing

Test across multiple browsers in E2E tests:

```typescript
// ✅ CORRECT: Cross-browser testing
import { test, expect, devices } from '@playwright/test';

// Test in multiple browsers
['chromium', 'firefox', 'webkit'].forEach((browserName) => {
  test.describe(`Customer Management - ${browserName}`, () => {
    test.use({ ...devices['Desktop Chrome'], browserName });

    test('should create customer', async ({ page }) => {
      // Test implementation
    });
  });
});

// Test mobile devices
test.describe('Customer Management - Mobile', () => {
  test.use({ ...devices['iPhone 13'] });

  test('should have touch-friendly buttons', async ({ page }) => {
    await page.goto('/customers');
    const button = page.getByRole('button', { name: 'New Customer' });
    
    // Verify minimum touch target size (44px)
    const box = await button.boundingBox();
    expect(box?.height).toBeGreaterThanOrEqual(44);
    expect(box?.width).toBeGreaterThanOrEqual(44);
  });
});
```

## Backend Testing Patterns

### NestJS Module Testing

ALWAYS test NestJS modules with proper dependency injection:

```typescript
// ✅ CORRECT: NestJS module testing
import { Test } from '@nestjs/testing';
import { CustomerModule } from './customer.module';
import { CustomerService } from './customer.service';
import { CustomerRepository } from './customer.repository';

describe('CustomerModule', () => {
  let module: TestingModule;
  let service: CustomerService;
  let repository: CustomerRepository;

  beforeEach(async () => {
    module = await Test.createTestingModule({
      imports: [CustomerModule],
    })
      .overrideProvider(CustomerRepository)
      .useValue(mockRepository)
      .compile();

    service = module.get<CustomerService>(CustomerService);
    repository = module.get<CustomerRepository>(CustomerRepository);
  });

  afterEach(async () => {
    await module.close();
  });

  it('should provide CustomerService', () => {
    expect(service).toBeDefined();
  });

  it('should inject dependencies correctly', () => {
    expect(service['repository']).toBe(repository);
  });
});
```

### Testing Guards and Interceptors

Test authentication and authorization guards:

```typescript
// ✅ CORRECT: Testing guards
import { ExecutionContext } from '@nestjs/common';
import { JwtAuthGuard } from './jwt-auth.guard';
import { RbacGuard } from './rbac.guard';

describe('JwtAuthGuard', () => {
  let guard: JwtAuthGuard;
  let context: ExecutionContext;

  beforeEach(() => {
    guard = new JwtAuthGuard();
    context = {
      switchToHttp: () => ({
        getRequest: () => ({
          headers: { authorization: 'Bearer valid-token' },
        }),
      }),
    } as ExecutionContext;
  });

  it('should allow request with valid token', async () => {
    jest.spyOn(jwtService, 'verify').mockReturnValue({ userId: 'user-123' });
    const result = await guard.canActivate(context);
    expect(result).toBe(true);
  });

  it('should reject request without token', async () => {
    context = {
      switchToHttp: () => ({
        getRequest: () => ({ headers: {} }),
      }),
    } as ExecutionContext;

    await expect(guard.canActivate(context)).rejects.toThrow();
  });
});

describe('RbacGuard', () => {
  it('should check entity-level permissions', async () => {
    const guard = new RbacGuard();
    const context = createMockContext({
      user: { role: 'ADM' },
      handler: { name: 'create' },
    });

    jest.spyOn(rbacService, 'hasPermission').mockReturnValue(true);
    const result = await guard.canActivate(context);
    expect(result).toBe(true);
  });
});
```

### Repository Testing

Test CouchDB repository operations:

```typescript
// ✅ CORRECT: Repository testing
import { CustomerRepository } from './customer.repository';
import { Nano } from 'nano';

describe('CustomerRepository', () => {
  let repository: CustomerRepository;
  let mockNano: jest.Mocked<Nano>;

  beforeEach(() => {
    mockNano = {
      use: jest.fn().mockReturnValue({
        get: jest.fn(),
        insert: jest.fn(),
        find: jest.fn(),
      }),
    } as any;

    repository = new CustomerRepository(mockNano);
  });

  it('should find customer by ID', async () => {
    const mockCustomer = { _id: 'customer-123', companyName: 'Test GmbH' };
    mockNano.use().get.mockResolvedValue(mockCustomer);

    const result = await repository.findById('customer-123');

    expect(result).toEqual(mockCustomer);
    expect(mockNano.use().get).toHaveBeenCalledWith('customer-123');
  });

  it('should handle CouchDB conflicts', async () => {
    const conflictError = new Error('Document update conflict');
    conflictError.status = 409;
    mockNano.use().insert.mockRejectedValue(conflictError);

    await expect(
      repository.create({ companyName: 'Test' } as Customer)
    ).rejects.toThrow('Document update conflict');
  });
});
```

### API Integration Testing

Test complete API request/response flows:

```typescript
// ✅ CORRECT: API integration testing
describe('Customer API Integration', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // Authenticate
    const loginResponse = await request(app.getHttpServer())
      .post('/auth/login')
      .send({ email: 'test@example.com', password: 'test123' });
    authToken = loginResponse.body.token;
  });

  describe('POST /api/v1/customers', () => {
    it('should validate request body', async () => {
      const response = await request(app.getHttpServer())
        .post('/api/v1/customers')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ companyName: 'A' }) // Too short
        .expect(400);

      expect(response.body).toMatchObject({
        type: expect.stringContaining('validation-error'),
        status: 400,
        errors: expect.arrayContaining([
          expect.objectContaining({
            field: 'companyName',
            message: expect.stringContaining('2-200 characters'),
          }),
        ]),
      });
    });

    it('should return RFC 7807 error format', async () => {
      const response = await request(app.getHttpServer())
        .post('/api/v1/customers')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ companyName: 'A' })
        .expect(400);

      expect(response.body).toHaveProperty('type');
      expect(response.body).toHaveProperty('title');
      expect(response.body).toHaveProperty('status');
      expect(response.body).toHaveProperty('detail');
      expect(response.body).toHaveProperty('instance');
    });
  });
});
```

### Security Testing

ALWAYS test security vulnerabilities:

```typescript
// ✅ CORRECT: Security testing
describe('Security Tests', () => {
  it('should prevent NoSQL injection', async () => {
    const maliciousInput = { $ne: null };
    const response = await request(app.getHttpServer())
      .post('/api/v1/customers')
      .set('Authorization', `Bearer ${authToken}`)
      .send({ companyName: maliciousInput })
      .expect(400);

    // Should be sanitized/rejected, not executed
    expect(response.body.errors).toBeDefined();
  });

  it('should enforce rate limiting', async () => {
    // Make 101 requests (limit is 100/minute)
    const requests = Array(101).fill(null).map(() =>
      request(app.getHttpServer())
        .get('/api/v1/customers')
        .set('Authorization', `Bearer ${authToken}`)
    );

    const responses = await Promise.all(requests);
    const rateLimited = responses.find((r) => r.status === 429);

    expect(rateLimited).toBeDefined();
    expect(rateLimited?.body).toMatchObject({
      status: 429,
      message: expect.stringContaining('Too many requests'),
    });
  });

  it('should validate JWT token expiration', async () => {
    const expiredToken = generateExpiredToken();
    const response = await request(app.getHttpServer())
      .get('/api/v1/customers')
      .set('Authorization', `Bearer ${expiredToken}`)
      .expect(401);

    expect(response.body).toMatchObject({
      status: 401,
      message: expect.stringContaining('token expired'),
    });
  });
});
```

## E2E Testing Patterns

### Page Object Model

ALWAYS use Page Object Model pattern for E2E tests:

```typescript
// ✅ CORRECT: Page Object Model
// tests/e2e/pages/CustomerPage.ts
export class CustomerPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/customers');
  }

  async clickNewCustomer() {
    await this.page.click('button:has-text("New Customer")');
  }

  async fillCompanyName(name: string) {
    await this.page.fill('[name="companyName"]', name);
  }

  async fillVATNumber(vat: string) {
    await this.page.fill('[name="vatNumber"]', vat);
  }

  async save() {
    await this.page.click('button:has-text("Save")');
  }

  async expectSuccessMessage() {
    await expect(this.page.locator('.toast-success')).toContainText('Customer created');
  }
}

// tests/e2e/customer/create-customer.spec.ts
import { test, expect } from '@playwright/test';
import { CustomerPage } from '../pages/CustomerPage';
import { LoginPage } from '../pages/LoginPage';

test.describe('Customer Creation', () => {
  test('should create new customer', async ({ page }) => {
    const loginPage = new LoginPage(page);
    const customerPage = new CustomerPage(page);

    await loginPage.login('adm@example.com', 'password123');
    await customerPage.goto();
    await customerPage.clickNewCustomer();
    await customerPage.fillCompanyName('Test GmbH');
    await customerPage.fillVATNumber('DE123456789');
    await customerPage.save();
    await customerPage.expectSuccessMessage();
  });
});
```

### Critical User Journeys

Focus E2E tests on critical user workflows:

```typescript
// ✅ CORRECT: Critical user journey test
test('Complete Customer to Opportunity to Project Workflow', async ({ page }) => {
  // 1. Create Customer
  await createCustomer(page, {
    companyName: 'Test Hofladen GmbH',
    vatNumber: 'DE123456789',
  });

  // 2. Create Opportunity
  await createOpportunity(page, {
    customerId: 'customer-123',
    title: 'New Store Installation',
    estimatedValue: 50000,
  });

  // 3. Convert Opportunity to Project
  await convertOpportunityToProject(page, 'opportunity-456');

  // 4. Verify Project Created
  await expect(page.locator('h1')).toContainText('New Store Installation');
  await expect(page.locator('[data-testid="project-budget"]')).toContainText('€50,000');
});
```

### Test Data Management

Use test data factories and fixtures:

```typescript
// ✅ CORRECT: Test data factories
// tests/fixtures/customer.factory.ts
export const createTestCustomer = (overrides?: Partial<Customer>): Customer => {
  return {
    _id: `customer-${generateId()}`,
    companyName: 'Test GmbH',
    vatNumber: 'DE123456789',
    billingAddress: {
      street: 'Teststraße',
      zipCode: '80331',
      city: 'München',
      country: 'Deutschland',
    },
    ...overrides,
  };
};

// tests/e2e/helpers/test-data.ts
export async function setupTestCustomer(page: Page): Promise<string> {
  const customer = createTestCustomer();
  
  // Create via API for faster setup
  await page.request.post('/api/v1/customers', {
    data: customer,
    headers: { Authorization: `Bearer ${testToken}` },
  });

  return customer._id;
}

// Use in tests
test('should edit customer', async ({ page }) => {
  const customerId = await setupTestCustomer(page);
  await page.goto(`/customers/${customerId}`);
  // Test implementation
});
```

### Error and Edge Case Testing

Test error scenarios and edge cases:

```typescript
// ✅ CORRECT: Error scenario testing
test('should handle network failure gracefully', async ({ page, context }) => {
  // Simulate offline
  await context.setOffline(true);

  await page.goto('/customers');
  await page.click('button:has-text("New Customer")');
  await page.fill('[name="companyName"]', 'Test GmbH');
  await page.click('button:has-text("Save")');

  // Should show offline message
  await expect(page.locator('.toast-info')).toContainText('Saved offline');
  await expect(page.locator('[data-testid="sync-status"]')).toContainText('Offline');

  // Go back online
  await context.setOffline(false);
  await page.click('[data-testid="sync-button"]');

  // Should sync and show success
  await expect(page.locator('.toast-success')).toContainText('Synced');
});

test('should handle validation errors', async ({ page }) => {
  await page.goto('/customers/new');
  await page.fill('[name="companyName"]', 'A'); // Too short
  await page.click('button:has-text("Save")');

  // Should show validation error
  await expect(page.locator('[data-testid="error-companyName"]')).toContainText(
    'Company name must be 2-200 characters'
  );
});
```

## Performance Testing

### API Response Time Testing

Test API performance against NFR targets:

```typescript
// ✅ CORRECT: Performance testing
describe('API Performance', () => {
  it('should respond within P50 target (400ms)', async () => {
    const start = Date.now();
    const response = await request(app.getHttpServer())
      .get('/api/v1/customers')
      .set('Authorization', `Bearer ${authToken}`);
    const duration = Date.now() - start;

    expect(response.status).toBe(200);
    expect(duration).toBeLessThan(400); // P50 target
  });

  it('should respond within P95 target (1.5s)', async () => {
    // Run multiple requests and measure P95
    const durations: number[] = [];
    
    for (let i = 0; i < 100; i++) {
      const start = Date.now();
      await request(app.getHttpServer())
        .get('/api/v1/customers')
        .set('Authorization', `Bearer ${authToken}`);
      durations.push(Date.now() - start);
    }

    durations.sort((a, b) => a - b);
    const p95 = durations[Math.floor(durations.length * 0.95)];

    expect(p95).toBeLessThan(1500); // P95 target
  });
});
```

### Load Testing

Use load testing tools for stress testing:

```typescript
// ✅ CORRECT: Load testing
import autocannon from 'autocannon';

describe('Load Testing', () => {
  it('should handle 20 concurrent users', async () => {
    const result = await autocannon({
      url: 'http://localhost:3000',
      connections: 20,
      duration: 30,
      requests: [
        {
          method: 'GET',
          path: '/api/v1/customers',
          headers: {
            Authorization: `Bearer ${authToken}`,
          },
        },
      ],
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // 100 req/s
    expect(result.latency.p95).toBeLessThan(1500); // P95 < 1.5s
  });
});
```

## Accessibility Testing

### WCAG 2.1 AA Compliance

ALWAYS test accessibility in E2E tests:

```typescript
// ✅ CORRECT: Accessibility testing with Playwright
import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

test('should have no accessibility violations', async ({ page }) => {
  await page.goto('/customers');
  
  const accessibilityScanResults = await new AxeBuilder({ page })
    .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])
    .analyze();

  expect(accessibilityScanResults.violations).toEqual([]);
});

test('should be keyboard navigable', async ({ page }) => {
  await page.goto('/customers');
  
  // Tab through interactive elements
  await page.keyboard.press('Tab');
  await expect(page.locator('button:has-text("New Customer")')).toBeFocused();
  
  await page.keyboard.press('Enter');
  await expect(page.locator('[name="companyName"]')).toBeFocused();
});

test('should have proper ARIA labels', async ({ page }) => {
  await page.goto('/customers');
  
  const button = page.getByRole('button', { name: 'New Customer' });
  await expect(button).toHaveAttribute('aria-label', 'Create new customer');
});
```

## Test Data Management

### Fixture Patterns

Use fixtures for reusable test data:

```typescript
// ✅ CORRECT: Test fixtures
// tests/fixtures/customers.fixture.ts
export const customerFixtures = {
  minimal: (): Customer => ({
    _id: 'customer-minimal',
    companyName: 'Minimal GmbH',
    billingAddress: testAddress,
  }),

  complete: (): Customer => ({
    _id: 'customer-complete',
    companyName: 'Complete GmbH',
    vatNumber: 'DE123456789',
    email: 'info@complete.de',
    phone: '+49-89-1234567',
    billingAddress: testAddress,
    locations: ['location-1', 'location-2'],
    contactPersons: ['contact-1'],
  }),

  multiLocation: (): Customer => ({
    _id: 'customer-multi',
    companyName: 'Multi-Location GmbH',
    locations: ['location-hq', 'location-branch-1', 'location-branch-2'],
    defaultDeliveryLocationId: 'location-hq',
  }),
};
```

### Database Seeding

Seed test databases before tests:

```typescript
// ✅ CORRECT: Database seeding
// tests/helpers/db-seed.ts
export async function seedTestDatabase() {
  const customers = [
    customerFixtures.minimal(),
    customerFixtures.complete(),
    customerFixtures.multiLocation(),
  ];

  for (const customer of customers) {
    await nano.use('kompass_test').insert(customer);
  }
}

// Use in tests
beforeAll(async () => {
  await seedTestDatabase();
});

afterAll(async () => {
  await cleanupTestDatabase();
});
```

## CI/CD Integration

### Test Execution in CI/CD

Configure tests to run in CI/CD pipeline:

```yaml
# ✅ CORRECT: CI/CD test configuration
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - run: pnpm install
      
      - name: Run unit tests
        run: pnpm test:unit
        
      - name: Run integration tests
        run: pnpm test:integration
        env:
          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
          
      - name: Run E2E tests
        run: pnpm test:e2e
        env:
          PLAYWRIGHT_BROWSERS_PATH: 0
```

### Test Parallelization

Run tests in parallel for faster execution:

```typescript
// ✅ CORRECT: Test parallelization
// playwright.config.ts
export default defineConfig({
  workers: process.env.CI ? 2 : 4, // Parallel workers
  fullyParallel: true, // Run all tests in parallel
  retries: process.env.CI ? 2 : 0, // Retry flaky tests in CI
});
```

### Flaky Test Handling

Handle flaky tests with retries and timeouts:

```typescript
// ✅ CORRECT: Flaky test handling
test('should sync offline changes', async ({ page }) => {
  test.setTimeout(30000); // Increase timeout for slow operations
  
  // Use waitFor with longer timeout
  await page.waitForSelector('[data-testid="sync-complete"]', {
    timeout: 10000,
  });
});

// Mark known flaky tests
test.describe('Flaky Tests', () => {
  test('should handle race condition', async ({ page }) => {
    test.info().annotations.push({
      type: 'flaky',
      description: 'Known race condition, investigating',
    });
    // Test implementation
  });
});
```

## References

- Test Strategy Document: `docs/specifications/test-strategy.md`
- Architecture Documentation: `docs/architectur/Projekt KOMPASS – Architekturdokumentation (Zielarchitektur).md`
- Playwright Documentation: https://playwright.dev/
- Jest Documentation: https://jestjs.io/
- React Testing Library: https://testing-library.com/react
- Vitest Documentation: https://vitest.dev/
