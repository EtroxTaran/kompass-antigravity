---
description: Comprehensive security practices - rate limiting, CSRF protection, XSS prevention, input sanitization, NoSQL injection prevention, error handling security, logging security, HTTPS enforcement, and CouchDB security
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---

# Security Best Practices

## Backend Security (NestJS)

### Security Headers

ALWAYS use Helmet for security headers:

```typescript
// ✅ CORRECT: Security headers with Helmet
import helmet from 'helmet';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Security headers
  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
    crossOriginEmbedderPolicy: false,
  }));
  
  await app.listen(3000);
}
```

### CORS Configuration

ALWAYS configure CORS explicitly:

```typescript
// ✅ CORRECT: Explicit CORS configuration
app.enableCors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  exposedHeaders: ['X-Total-Count'],
  maxAge: 86400, // 24 hours
});

// ❌ WRONG: Allow all origins
app.enableCors(); // Security risk!
```

### Rate Limiting

ALWAYS implement rate limiting:

```typescript
// ✅ CORRECT: Rate limiting with @nestjs/throttler
import { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';

@Module({
  imports: [
    ThrottlerModule.forRoot({
      ttl: 60,
      limit: 100, // 100 requests per minute
    }),
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: ThrottlerGuard,
    },
  ],
})
export class AppModule {}

// Custom rate limits for specific endpoints
@Throttle(10, 60) // 10 requests per minute
@Post('login')
async login() {
  // Login endpoint with stricter rate limit
}
```

### CSRF Protection

For state-changing operations, implement CSRF protection:

```typescript
// ✅ CORRECT: CSRF protection
import * as csurf from 'csurf';

// Only enable CSRF for non-API routes or when using cookies
if (process.env.ENABLE_CSRF === 'true') {
  app.use(csurf({
    cookie: {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    },
  }));
}
```

### Input Sanitization

ALWAYS sanitize user input in addition to validation:

```typescript
// ✅ CORRECT: Input sanitization
import { Transform } from 'class-transformer';
import { sanitize } from 'class-sanitizer';

export class CreateCustomerDto {
  @Transform(({ value }) => sanitize(value)) // Remove HTML tags
  @IsString()
  @Length(2, 200)
  companyName: string;
}

// ✅ CORRECT: Sanitize in service layer
import DOMPurify from 'isomorphic-dompurify';

async create(dto: CreateCustomerDto): Promise<Customer> {
  // Sanitize HTML content
  const sanitizedCompanyName = DOMPurify.sanitize(dto.companyName, {
    ALLOWED_TAGS: [], // No HTML tags allowed
    ALLOWED_ATTR: [],
  });
  
  // Continue with sanitized data
}
```

### NoSQL Injection Prevention

ALWAYS validate and sanitize CouchDB queries:

```typescript
// ✅ CORRECT: Safe CouchDB queries
async findCustomers(filters: CustomerFilters): Promise<Customer[]> {
  // Use Mango query selector (safe)
  const query = {
    selector: {
      type: 'customer',
      companyName: { $regex: `^${this.escapeRegex(filters.search)}` },
    },
    limit: 100,
  };
  
  return this.repository.find(query);
}

private escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ❌ WRONG: String concatenation in queries
async findCustomers(search: string): Promise<Customer[]> {
  // Dangerous - NoSQL injection risk
  const query = `function(doc) { return doc.companyName.indexOf('${search}') !== -1; }`;
}
```

### Error Handling Security

NEVER expose stack traces or sensitive information in production:

```typescript
// ✅ CORRECT: Secure error handling
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    const message = exception instanceof HttpException
      ? exception.getResponse()
      : 'Internal server error';

    // Log full error details server-side
    this.logger.error({
      message: exception instanceof Error ? exception.message : 'Unknown error',
      stack: exception instanceof Error ? exception.stack : undefined,
      url: request.url,
      method: request.method,
    });

    // Return sanitized error to client
    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: process.env.NODE_ENV === 'production'
        ? 'An error occurred' // Generic message in production
        : message, // Detailed message in development
    });
  }
}
```

### Logging Security

NEVER log sensitive data:

```typescript
// ✅ CORRECT: Sanitized logging
logger.log('Customer created', {
  customerId: customer.id,
  userId: user.id,
  // DO NOT log: passwords, tokens, credit card numbers, etc.
});

// ❌ WRONG: Logging sensitive data
logger.log('Login attempt', {
  email: user.email,
  password: dto.password, // NEVER log passwords!
  token: jwtToken, // NEVER log tokens!
});
```

### Environment Variable Validation

ALWAYS validate environment variables at startup:

```typescript
// ✅ CORRECT: Environment variable validation
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32), // Minimum 32 characters
  ALLOWED_ORIGINS: z.string(),
  COUCHDB_ADMIN_USER: z.string(),
  COUCHDB_ADMIN_PASSWORD: z.string().min(16),
});

export function validateEnv(): z.infer<typeof envSchema> {
  try {
    return envSchema.parse(process.env);
  } catch (error) {
    console.error('❌ Invalid environment variables:', error);
    process.exit(1);
  }
}

export const config = validateEnv();
```

### HTTPS Enforcement

ALWAYS enforce HTTPS in production:

```typescript
// ✅ CORRECT: HTTPS enforcement middleware
if (process.env.NODE_ENV === 'production') {
  app.use((req, res, next) => {
    if (req.header('x-forwarded-proto') !== 'https') {
      res.redirect(`https://${req.header('host')}${req.url}`);
    } else {
      next();
    }
  });
}
```

## Frontend Security (React)

### Content Security Policy

ALWAYS implement CSP in production:

```typescript
// ✅ CORRECT: CSP meta tag in index.html
<meta
  httpEquiv="Content-Security-Policy"
  content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval';
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self' data:;
    connect-src 'self' https://api.kompass.de;
    frame-ancestors 'none';
  "
/>
```

### XSS Prevention

ALWAYS sanitize user-generated content:

```typescript
// ✅ CORRECT: Sanitize user input
import DOMPurify from 'isomorphic-dompurify';

function CustomerDescription({ description }: { description: string }) {
  const sanitized = DOMPurify.sanitize(description, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em'],
    ALLOWED_ATTR: [],
  });

  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}

// ✅ BETTER: Use React's built-in escaping
function CustomerDescription({ description }: { description: string }) {
  return <div>{description}</div>; // React escapes by default
}
```

### Secure Storage

NEVER store sensitive data in localStorage:

```typescript
// ✅ CORRECT: Use httpOnly cookies for tokens
// Tokens stored in httpOnly cookies (set by backend)
// Frontend cannot access via JavaScript

// ✅ CORRECT: Store non-sensitive data in localStorage
localStorage.setItem('theme', 'dark');
localStorage.setItem('language', 'de');

// ❌ WRONG: Store sensitive data in localStorage
localStorage.setItem('jwtToken', token); // XSS vulnerability!
localStorage.setItem('password', password); // NEVER!
```

### Secure API Communication

ALWAYS use HTTPS and validate certificates:

```typescript
// ✅ CORRECT: Secure API client
const apiClient = axios.create({
  baseURL: process.env.REACT_APP_API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
  // Validate SSL certificates
  httpsAgent: new https.Agent({
    rejectUnauthorized: process.env.NODE_ENV === 'production',
  }),
});

// Add request interceptor for auth
apiClient.interceptors.request.use((config) => {
  // Token is in httpOnly cookie, automatically sent
  return config;
});
```

### Dependency Vulnerability Scanning

ALWAYS scan dependencies for vulnerabilities:

```bash
# ✅ CORRECT: Regular dependency scanning
pnpm audit
pnpm audit --fix

# Add to CI/CD pipeline
# - Run pnpm audit in CI
# - Fail build if critical vulnerabilities found
# - Auto-update dependencies with pnpm update
```

## CouchDB Security

### Database-Level Security

ALWAYS configure CouchDB _security documents:

```typescript
// ✅ CORRECT: CouchDB security configuration
interface CouchDBSecurity {
  admins: {
    names: string[];
    roles: string[];
  };
  members: {
    names: string[];
    roles: string[];
  };
}

// Example: Customer database security
const customerDbSecurity: CouchDBSecurity = {
  admins: {
    names: [],
    roles: ['admin', 'crm_admin'],
  },
  members: {
    names: [],
    roles: ['sales', 'crm_user', 'admin'],
  },
};

// Apply security
await nano.db('kompass_customers').setSecurity(customerDbSecurity);
```

### Validate Functions

ALWAYS use validate functions to prevent unauthorized writes:

```typescript
// ✅ CORRECT: CouchDB validate function
const validateFunction = `
function(newDoc, oldDoc, userCtx, secObj) {
  // Check document type
  if (newDoc.type !== 'customer') {
    throw({forbidden: 'Invalid document type'});
  }
  
  // Check ownership
  if (userCtx.roles.indexOf('admin') === -1) {
    if (newDoc.owner !== userCtx.name) {
      throw({forbidden: 'You can only modify your own customers'});
    }
  }
  
  // Check required fields
  if (!newDoc.companyName || newDoc.companyName.length < 2) {
    throw({forbidden: 'Company name is required and must be at least 2 characters'});
  }
}
`;

// Install validate function
await nano.db('kompass_customers').insert({
  _id: '_design/validate',
  validate_doc_update: validateFunction,
});
```

### Replication Security

ALWAYS secure CouchDB replication:

```typescript
// ✅ CORRECT: Secure replication with authentication
const replicationOptions = {
  source: 'http://admin:password@couchdb:5984/kompass_customers',
  target: localDB,
  filter: 'design_doc/filter_by_role', // Filter documents by role
  query_params: {
    role: userRole,
  },
  auth: {
    username: 'couchdb_user',
    password: 'secure_password',
  },
};

// ❌ WRONG: Unauthenticated replication
const replicationOptions = {
  source: 'http://couchdb:5984/kompass_customers', // No auth!
};
```

## Secrets Management

### Environment Variables

NEVER commit secrets to git:

```bash
# ✅ CORRECT: .gitignore includes .env files
.env
.env.local
.env.*.local
*.env

# ✅ CORRECT: Use .env.example template
# .env.example (committed to git)
JWT_SECRET=your-secret-key-here-min-32-chars
DATABASE_URL=http://localhost:5984
COUCHDB_ADMIN_USER=admin
COUCHDB_ADMIN_PASSWORD=your-secure-password-here

# ❌ WRONG: Committing .env with real values
# .env (should be in .gitignore)
JWT_SECRET=actual-secret-key # NEVER commit this!
```

### Secret Rotation

ALWAYS implement secret rotation:

```typescript
// ✅ CORRECT: Support multiple secrets for rotation
const jwtSecrets = [
  process.env.JWT_SECRET_CURRENT,
  process.env.JWT_SECRET_PREVIOUS, // For graceful rotation
];

// Verify token with current or previous secret
function verifyToken(token: string): Payload {
  for (const secret of jwtSecrets) {
    try {
      return jwt.verify(token, secret);
    } catch (error) {
      continue;
    }
  }
  throw new UnauthorizedException('Invalid token');
}
```

## Session Management

### Secure Session Configuration

```typescript
// ✅ CORRECT: Secure session configuration
app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true, // Prevent XSS
      secure: process.env.NODE_ENV === 'production', // HTTPS only
      sameSite: 'strict', // CSRF protection
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    },
  })
);
```

## Password Policies

### Password Requirements

Enforce strong password policies:

```typescript
// ✅ CORRECT: Password validation
import { Matches, MinLength } from 'class-validator';

export class CreateUserDto {
  @MinLength(12)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message: 'Password must contain uppercase, lowercase, number, and special character',
  })
  password: string;
}

// Password requirements:
// - Minimum 12 characters
// - At least one uppercase letter
// - At least one lowercase letter
// - At least one number
// - At least one special character
```

## API Security

### Request Size Limits

ALWAYS limit request body size:

```typescript
// ✅ CORRECT: Request size limits
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ limit: '10mb', extended: true }));

// Prevent DoS attacks from large payloads
```

### API Versioning Security

ALWAYS validate API version:

```typescript
// ✅ CORRECT: API version validation
@Controller('api/v1/customers')
export class CustomerControllerV1 {
  // V1 endpoints
}

@Controller('api/v2/customers')
export class CustomerControllerV2 {
  // V2 endpoints with improved security
}

// Deprecate old versions securely
@Get()
@ApiDeprecated()
async findAllV1() {
  // Return deprecation warning
  throw new HttpException(
    'API v1 is deprecated. Please migrate to v2.',
    HttpStatus.GONE
  );
}
```

## Security Testing

### Security Test Requirements

```typescript
// ✅ CORRECT: Security tests
describe('Security', () => {
  it('should reject requests without authentication', async () => {
    await request(app.getHttpServer())
      .get('/api/v1/customers')
      .expect(401);
  });

  it('should reject requests with invalid JWT', async () => {
    await request(app.getHttpServer())
      .get('/api/v1/customers')
      .set('Authorization', 'Bearer invalid-token')
      .expect(401);
  });

  it('should prevent SQL injection', async () => {
    const maliciousInput = "'; DROP TABLE customers; --";
    // Test that malicious input is sanitized
  });

  it('should prevent XSS attacks', async () => {
    const xssPayload = '<script>alert("XSS")</script>';
    // Test that XSS payload is sanitized
  });
});
```

## Related Rules

- Security & Compliance: `.cursor/rules/security-compliance.mdc` - RBAC, DSGVO, GoBD
- Error Handling: `.cursor/rules/error-handling.mdc` - Secure error handling patterns
- Dependency Management: `.cursor/rules/dependency-management.mdc` - Dependency security

## References

- NestJS Security: https://docs.nestjs.com/security/authentication
- OWASP Top 10: https://owasp.org/www-project-top-ten/
- CouchDB Security: https://docs.couchdb.org/en/stable/security/
- React Security: https://react.dev/learn/escape-hatches
