---
description: Graphiti MCP memory usage requirements - when and how to store architectural decisions, infrastructure changes, routing updates, refactors, and bug fixes for long-term context retention
globs: []
alwaysApply: true
---

# Graphiti Memory Usage

## Overview

Graphiti MCP provides persistent, project-scoped long-term memory for the KOMPASS repository. This memory enables Cursor AI agents to retain context about architectural decisions, infrastructure changes, patterns, and fixes across development sessions.

**Setup:** See `docs/guides/graphiti-memory.md` for installation, configuration, and lifecycle management.

**Stack Status:** The Graphiti MCP stack MUST be running (`./scripts/start-memory.sh`) whenever developing on this repository. Cursor depends on `http://localhost:8000/mcp/` for memory access.

## MANDATORY: When to Store Information in Graphiti

You MUST use Graphiti MCP tools to store information in the following scenarios:

### 1. Architectural Decisions & ADR Context

**ALWAYS store when:**
- Making significant technology choices (database, framework, library changes)
- Deciding on architectural patterns (before or after creating ADR files)
- Making trade-off decisions with multiple valid options
- Changing system design that affects multiple modules

**What to store:**
- Decision context and rationale
- Alternatives considered and why they were rejected
- Consequences and implementation notes
- Link to ADR file if one exists

**Example:**
```typescript
// After deciding to use NestJS for backend
// Store in Graphiti: "Architectural decision to use NestJS for backend.
// Rationale: TypeScript-first, decorator-based architecture aligns with 
// team expertise. Rejected Express.js due to lack of built-in dependency 
// injection. See ADR-001 for details."
```

### 2. Docker & Container Infrastructure Changes

**ALWAYS store when:**
- Adding or modifying `docker-compose*.yml` files
- Creating new infrastructure scripts (`scripts/start-*.sh`, `scripts/stop-*.sh`)
- Changing container configuration, volumes, networks
- Updating environment variable requirements
- Modifying infrastructure documentation

**What to store:**
- What changed and why
- Impact on local development workflow
- Required manual steps for other developers
- Environment variable updates needed

**Example:**
```bash
# After adding Graphiti MCP stack
# Store in Graphiti: "Added infra/graphiti-mcp/ docker-compose stack.
# New scripts: start-memory.sh, stop-memory.sh. Requires OPENAI_API_KEY
# in infra/graphiti-mcp/.env.template (copy to .env). Stack must run
# during development for Cursor MCP integration."
```

### 3. Routing & Navigation Updates

**ALWAYS store when:**
- Changing route paths or navigation structure
- Adding new pages or redirects
- Modifying landing page flows (e.g., A → B → C changes)
- Updating URL patterns or query parameters
- Changing authentication/authorization redirects

**What to store:**
- Old route/navigation structure
- New route/navigation structure
- Reason for change (user experience, security, etc.)
- Migration notes for existing links/bookmarks

**Example:**
```typescript
// After changing customer detail route from /customers/:id to /customers/:id/details
// Store in Graphiti: "Changed customer detail route from /customers/:id 
// to /customers/:id/details to accommodate new sub-routes. Old route 
// redirects to new route for backward compatibility. Updated all internal 
// navigation links. See routing.md for full route map."
```

### 4. Important Implementation Patterns & Refactors

**ALWAYS store when:**
- Extracting shared code to `packages/shared/`
- Creating reusable hooks, services, or utilities
- Refactoring complex logic patterns
- Establishing new coding conventions or patterns
- Migrating from one pattern to another

**What to store:**
- Pattern description and use cases
- Before/after code structure
- Migration path for existing code
- Examples of correct usage

**Example:**
```typescript
// After extracting RBAC logic to shared guard
// Store in Graphiti: "Refactored RBAC permission checks into reusable 
// RbacGuard. Pattern: @RequirePermission(entity, action) decorator on 
// controller methods. All services should use this guard instead of 
// inline permission checks. See rbac.guard.ts for implementation."
```

### 5. Non-Trivial Bugs & Fixes

**ALWAYS store when:**
- Fixing complex bugs with non-obvious root causes
- Implementing workarounds for third-party library issues
- Resolving performance bottlenecks
- Fixing data corruption or sync issues
- Addressing security vulnerabilities

**What to store:**
- Bug description and symptoms
- Root cause analysis
- Fix implementation details
- Preventive measures (tests, validations) added
- Related Linear issue ID

**Example:**
```typescript
// After fixing CouchDB conflict resolution issue
// Store in Graphiti: "Fixed offline sync conflict resolution bug (KOM-456).
// Root cause: Last-write-wins strategy didn't handle nested object updates
// correctly. Fix: Implemented field-level merge for non-conflicting fields.
// Added conflict detection tests in customer.service.spec.ts. Pattern now
// used for all entity sync operations."
```

## How to Store Information in Graphiti

### Using MCP Tools

When working in Cursor with Graphiti MCP enabled, use the available MCP tools:

1. **`add_episode`** - Store text, messages, or JSON data as an episode
2. **`search_facts`** - Search for previously stored facts
3. **`search_nodes`** - Find entity nodes and relationships
4. **`get_episode`** - Retrieve a specific episode by ID

### Best Practices

- **Use descriptive names**: Episode names should clearly describe the content (e.g., "Architectural Decision: NestJS Backend", "Bug Fix: CouchDB Conflict Resolution")
- **Include context**: Store enough context that a future developer/agent can understand the decision or fix
- **Link to documentation**: Reference ADR files, Linear issues, or code files when relevant
- **Use consistent group_id**: Always use `kompass-memory` (configured in `.cursor/mcp.json`) to namespace data

### Example MCP Tool Usage

When making an architectural decision:

```
Use add_episode with:
- name: "ADR-005: Graphiti MCP Integration"
- episode_body: Full decision context and rationale
- source: "documentation" or "code"
- source_description: "Architectural decision for long-term memory"
```

## Workflow Integration

### During Development

1. **Before starting work**: Ensure Graphiti stack is running (`./scripts/start-memory.sh`)
2. **During implementation**: Store relevant decisions, patterns, and changes as you make them
3. **After fixing bugs**: Document complex fixes in Graphiti
4. **When refactoring**: Store pattern changes and migration notes

### When Creating ADRs

- Store ADR context in Graphiti BEFORE or AFTER creating the ADR file
- Graphiti provides searchable, semantic memory beyond static files
- ADR files remain the authoritative source; Graphiti augments with context

### During Code Reviews

- Reviewers should check that significant changes have corresponding Graphiti entries
- Use `search_facts` or `search_nodes` to recall related decisions or patterns
- Store review feedback if it leads to pattern changes

## Verification

### Checking Stack Status

```bash
# Verify Graphiti stack is running
curl http://localhost:8000/health

# Check Docker container status
docker compose -f infra/graphiti-mcp/docker-compose.yml ps

# View logs if issues
docker compose -f infra/graphiti-mcp/docker-compose.yml logs -f
```

### Searching Stored Memory

When you need to recall information:
- Use `search_facts` with keywords related to your query
- Use `search_nodes` to find related entities (decisions, patterns, bugs)
- Graphiti's semantic search will return relevant episodes even with partial matches

## References

- Setup Guide: `docs/guides/graphiti-memory.md`
- Graphiti MCP Documentation: https://github.com/getzep/graphiti/blob/main/mcp_server/README.md
- Cursor MCP Configuration: `.cursor/mcp.json`
