---
description: RESTful conventions (HTTP methods, URL structure), versioned APIs, RFC 7807 error responses, DTO validation, and OpenAPI/Swagger documentation requirements
globs: ["**/*controller*.ts", "**/*route*.ts", "**/*api*.ts", "**/*dto*.ts"]
alwaysApply: true
---

# API Design (REST + OpenAPI)

## RESTful Conventions

### HTTP Methods

Use HTTP methods semantically:

```typescript
// ✅ CORRECT: Proper HTTP method usage
@Controller('api/v1/customers')
export class CustomerController {
  @Get()           // List customers
  @Get(':id')      // Get single customer
  @Post()          // Create customer
  @Put(':id')      // Update customer (full replacement)
  @Patch(':id')    // Update customer (partial)
  @Delete(':id')   // Delete customer
}

// ❌ WRONG: Using wrong methods
@Post('getCustomer')  // Should be @Get()
@Get('createCustomer') // Should be @Post()
```

### URL Structure

Use resource-based URLs:

```typescript
// ✅ CORRECT: Resource-based URLs
/api/v1/customers
/api/v1/customers/:id
/api/v1/customers/:id/contacts
/api/v1/opportunities
/api/v1/opportunities/:id/offers

// ❌ WRONG: Action-based URLs
/api/v1/getCustomers
/api/v1/createCustomer
/api/v1/customer/list
```

## Versioned APIs

### Header-Based Versioning

```typescript
// ✅ CORRECT: Version in header
@Controller('api/customers')
@ApiVersion('1')
export class CustomerController {
  // Accessible at /api/customers with header: X-API-Version: 1
}

// ✅ Also support path-based for simplicity
@Controller('api/v1/customers')
export class CustomerControllerV1 {
  // Accessible at /api/v1/customers
}
```

## Consistent Error Responses (RFC 7807)

### Error Response Format

```typescript
// ✅ CORRECT: RFC 7807 Problem Details
interface ProblemDetails {
  type: string;        // URI reference to problem type
  title: string;       // Human-readable summary
  status: number;      // HTTP status code
  detail?: string;     // Human-readable explanation
  instance?: string;   // URI reference to specific occurrence
  [key: string]: unknown;  // Additional context
}

// Example error response
{
  "type": "https://api.kompass.de/errors/validation-error",
  "title": "Validation Failed",
  "status": 400,
  "detail": "Company name must be 2-200 characters",
  "instance": "/api/v1/customers",
  "errors": [
    {
      "field": "companyName",
      "message": "Company name must be 2-200 characters",
      "value": "A"
    }
  ]
}
```

### Error Status Codes

- **400 Bad Request**: Validation errors, malformed requests
- **401 Unauthorized**: Missing or invalid authentication
- **403 Forbidden**: Valid authentication but insufficient permissions
- **404 Not Found**: Resource doesn't exist
- **409 Conflict**: Resource conflict (e.g., duplicate)
- **500 Internal Server Error**: Unexpected server errors

## Request Validation with DTOs

### DTO Pattern

```typescript
// ✅ CORRECT: Complete DTO with validation
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsEmail, Length, Matches, IsOptional } from 'class-validator';

export class CreateCustomerDto {
  @ApiProperty({
    description: 'Company name',
    example: 'Hofladen Müller GmbH',
    minLength: 2,
    maxLength: 200,
  })
  @IsString()
  @Length(2, 200)
  @Matches(/^[a-zA-ZäöüÄÖÜß0-9\s\.\-&()]+$/, {
    message: 'Company name contains invalid characters'
  })
  companyName: string;

  @ApiProperty({
    description: 'German VAT number',
    example: 'DE123456789',
    required: false,
  })
  @IsString()
  @Matches(/^DE\d{9}$/, {
    message: 'VAT number must be format: DE123456789'
  })
  @IsOptional()
  vatNumber?: string;

  @ApiProperty({
    description: 'Company email',
    example: 'info@hofladen-mueller.de',
    required: false,
  })
  @IsEmail()
  @IsOptional()
  email?: string;
}
```

## OpenAPI Documentation

### Swagger Decorators

```typescript
// ✅ CORRECT: Complete OpenAPI documentation
@Controller('api/v1/customers')
@ApiTags('Customers')
@ApiBearerAuth()
export class CustomerController {
  @Get(':id')
  @ApiOperation({ summary: 'Get customer by ID' })
  @ApiParam({ name: 'id', description: 'Customer ID' })
  @ApiResponse({ 
    status: 200, 
    description: 'Customer found',
    type: CustomerResponseDto 
  })
  @ApiResponse({ 
    status: 404, 
    description: 'Customer not found' 
  })
  @ApiResponse({ 
    status: 403, 
    description: 'Forbidden - insufficient permissions' 
  })
  async findOne(
    @Param('id') id: string,
    @CurrentUser() user: User
  ): Promise<CustomerResponseDto> {
    return this.customerService.findById(id, user);
  }

  @Post()
  @ApiOperation({ summary: 'Create new customer' })
  @ApiBody({ type: CreateCustomerDto })
  @ApiResponse({ 
    status: 201, 
    description: 'Customer created',
    type: CustomerResponseDto 
  })
  @ApiResponse({ 
    status: 400, 
    description: 'Validation error' 
  })
  async create(
    @Body() dto: CreateCustomerDto,
    @CurrentUser() user: User
  ): Promise<CustomerResponseDto> {
    return this.customerService.create(dto, user);
  }
}
```

## Request/Response Patterns

### Pagination

```typescript
// ✅ CORRECT: Paginated response
interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
  };
}

@Get()
async findAll(
  @Query('page') page: number = 1,
  @Query('pageSize') pageSize: number = 20,
): Promise<PaginatedResponse<CustomerResponseDto>> {
  return this.customerService.findAll(page, pageSize);
}
```

### Filtering and Sorting

```typescript
// ✅ CORRECT: Filtering and sorting
@Get()
async findAll(
  @Query('search') search?: string,
  @Query('rating') rating?: 'A' | 'B' | 'C',
  @Query('sortBy') sortBy: string = 'companyName',
  @Query('sortOrder') sortOrder: 'asc' | 'desc' = 'asc',
): Promise<CustomerResponseDto[]> {
  return this.customerService.findAll({
    search,
    rating,
    sortBy,
    sortOrder,
  });
}
```

## Idempotency

### Idempotency Keys

For POST operations that should be idempotent:

```typescript
// ✅ CORRECT: Idempotency key support
@Post()
@Header('Idempotency-Key', 'optional')
async create(
  @Body() dto: CreateCustomerDto,
  @Headers('idempotency-key') idempotencyKey?: string,
  @CurrentUser() user: User
): Promise<CustomerResponseDto> {
  if (idempotencyKey) {
    const existing = await this.idempotencyService.find(idempotencyKey);
    if (existing) {
      return existing.result;
    }
  }

  const result = await this.customerService.create(dto, user);

  if (idempotencyKey) {
    await this.idempotencyService.store(idempotencyKey, result);
  }

  return result;
}
```

## API Documentation Requirements

### Required Documentation

Every endpoint MUST have:

1. **Summary**: Brief description
2. **Parameters**: All path, query, and body parameters
3. **Responses**: All possible response codes
4. **Examples**: Request/response examples
5. **Authentication**: Required auth method

### Swagger Setup

```typescript
// main.ts
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

const config = new DocumentBuilder()
  .setTitle('KOMPASS API')
  .setDescription('KOMPASS CRM and Project Management API')
  .setVersion('1.0')
  .addBearerAuth()
  .build();

const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('api/docs', app, document);
```

## References

- API Specification: `docs/reviews/API_SPECIFICATION.md`
- RFC 7807: https://tools.ietf.org/html/rfc7807
- OpenAPI Specification: https://swagger.io/specification/
- NestJS Swagger: https://docs.nestjs.com/openapi/introduction
