---
description: RBAC guards on all endpoints, DSGVO compliance (consent management, data retention), GoBD compliance (immutability after finalization), audit trail, and input validation
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: true
---

# Security & Compliance

## Authentication & Authorization

### No Secrets in Code

NEVER hardcode secrets in code:

```typescript
// ✅ CORRECT: Environment variables
const jwtSecret = process.env.JWT_SECRET;
const dbPassword = process.env.DB_PASSWORD;

if (!jwtSecret) {
  throw new Error('JWT_SECRET environment variable is required');
}

// ❌ WRONG: Hardcoded secrets
const jwtSecret = 'my-super-secret-key'; // NEVER DO THIS
const dbPassword = 'password123'; // NEVER DO THIS
```

### RBAC Guards on All Endpoints

EVERY controller method MUST have guards:

```typescript
// ✅ CORRECT: Guards on controller methods
@Controller('customers')
@UseGuards(JwtAuthGuard, RbacGuard)
export class CustomerController {
  @Get(':id')
  @RequirePermission('Customer', 'READ')
  async findOne(
    @Param('id') id: string,
    @CurrentUser() user: User
  ): Promise<CustomerResponseDto> {
    return this.customerService.findById(id, user);
  }

  @Post()
  @RequirePermission('Customer', 'CREATE')
  async create(
    @Body() createCustomerDto: CreateCustomerDto,
    @CurrentUser() user: User
  ): Promise<CustomerResponseDto> {
    return this.customerService.create(createCustomerDto, user);
  }
}

// ❌ WRONG: No guards
@Controller('customers')
export class CustomerController {
  @Get(':id')
  async findOne(@Param('id') id: string) { // No auth check!
    return this.customerService.findById(id);
  }
}
```

## Input Validation

### Always Validate User Input

```typescript
// ✅ CORRECT: DTO with validation
import { IsString, IsEmail, Length, Matches, IsOptional } from 'class-validator';

export class CreateCustomerDto {
  @IsString()
  @Length(2, 200)
  @Matches(/^[a-zA-ZäöüÄÖÜß0-9\s\.\-&()]+$/, {
    message: 'Company name contains invalid characters'
  })
  companyName: string;

  @IsString()
  @Matches(/^DE\d{9}$/, {
    message: 'VAT number must be format: DE123456789'
  })
  @IsOptional()
  vatNumber?: string;

  @IsEmail()
  @IsOptional()
  email?: string;
}

// ❌ WRONG: No validation
export class CreateCustomerDto {
  companyName: string; // No validation!
  vatNumber?: string;
  email?: string;
}
```

## Audit Trail

### Log All Data Modifications

```typescript
// ✅ CORRECT: Audit trail for modifications
async update(id: string, updates: Partial<Customer>, user: User): Promise<Customer> {
  const existing = await this.repository.findById(id);
  
  // Log changes
  const changes = this.detectChanges(existing, updates);
  for (const change of changes) {
    await this.auditService.log({
      entityType: 'Customer',
      entityId: id,
      action: 'UPDATE',
      field: change.field,
      oldValue: change.oldValue,
      newValue: change.newValue,
      userId: user.id,
      timestamp: new Date(),
      ipAddress: user.ipAddress,
    });
  }
  
  // Update entity
  const updated = { ...existing, ...updates };
  updated.modifiedBy = user.id;
  updated.modifiedAt = new Date();
  updated.version += 1;
  
  return await this.repository.update(updated);
}
```

## DSGVO Compliance

### Consent Management

```typescript
// ✅ CORRECT: DSGVO consent structure
interface DSGVOConsent {
  marketing: boolean;
  aiProcessing: boolean;
  dataSharing: boolean;
  grantedAt?: Date;
  grantedBy?: string;
  revokedAt?: Date;
}

// Check consent before AI processing
async processWithAI(customer: Customer): Promise<void> {
  if (!customer.dsgvoConsent?.aiProcessing) {
    throw new ForbiddenException('AI processing requires customer consent');
  }
  // ... proceed with AI processing
}
```

### Data Retention

```typescript
// ✅ CORRECT: Automatic data retention
async enforceDataRetention(): Promise<void> {
  const customers = await this.repository.find({
    dataRetentionUntil: { $lt: new Date() },
    anonymized: false,
  });

  for (const customer of customers) {
    // GoBD: Must keep financial records for 10 years
    // DSGVO: Must delete personal data after retention period
    await this.anonymizeCustomer(customer);
  }
}

async anonymizeCustomer(customer: Customer): Promise<void> {
  // Keep financial data (GoBD), anonymize personal data (DSGVO)
  customer.companyName = `Customer-${customer.id}`;
  customer.email = null;
  customer.phone = null;
  customer.anonymized = true;
  customer.anonymizedAt = new Date();
  
  await this.repository.update(customer);
}
```

## GoBD Compliance

### Immutability After Finalization

```typescript
// ✅ CORRECT: Enforce immutability
async updateInvoice(id: string, updates: Partial<Invoice>, user: User): Promise<Invoice> {
  const invoice = await this.repository.findById(id);
  
  if (invoice.finalized) {
    // Check if trying to modify immutable fields
    const immutableFields = [
      'invoiceNumber', 'invoiceDate', 'customer',
      'lineItems', 'subtotal', 'taxAmount', 'totalAmount'
    ];
    
    const attemptedChanges = Object.keys(updates);
    const immutableAttempts = attemptedChanges.filter(field => 
      immutableFields.includes(field)
    );
    
    if (immutableAttempts.length > 0) {
      if (user.role !== 'GF') {
        throw new ForbiddenException(
          `Cannot modify finalized invoice fields: ${immutableAttempts.join(', ')}. Requires GF approval.`
        );
      }
      
      // GF approval: Log correction
      for (const field of immutableAttempts) {
        invoice.changeLog.push({
          field,
          oldValue: invoice[field],
          newValue: updates[field],
          changedBy: user.id,
          changedAt: new Date(),
          reason: updates._correctionReason || 'Correction by GF',
          approvedBy: user.id,
        });
      }
    }
  }
  
  return await this.repository.update({ ...invoice, ...updates });
}
```

### Change Log Pattern

All immutable entities MUST have changeLog:

```typescript
interface ChangeLogEntry {
  field: string;
  oldValue: unknown;
  newValue: unknown;
  changedBy: string;     // User ID
  changedAt: Date;
  reason: string;        // REQUIRED for post-immutability changes
  approvedBy?: string;   // GF approval for significant changes
}

interface GoBDEntity extends BaseEntity {
  changeLog: ChangeLogEntry[];
  immutableAt?: Date;        // When entity became immutable
  immutableHash?: string;    // SHA-256 hash for tamper detection
  finalized?: boolean;       // True = locked
}
```

## Security Headers

### Required Security Headers

```typescript
// ✅ CORRECT: Security headers in main.ts
import helmet from 'helmet';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Security headers with CSP
  app.use(helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
    crossOriginEmbedderPolicy: false,
  }));
  
  // CORS with explicit configuration
  app.enableCors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    exposedHeaders: ['X-Total-Count'],
    maxAge: 86400, // 24 hours
  });
  
  await app.listen(3000);
}
```

## Rate Limiting

### API Rate Limiting

ALWAYS implement rate limiting to prevent DoS attacks:

```typescript
// ✅ CORRECT: Rate limiting with @nestjs/throttler
import { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';

@Module({
  imports: [
    ThrottlerModule.forRoot({
      ttl: 60,
      limit: 100, // 100 requests per minute
    }),
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: ThrottlerGuard,
    },
  ],
})
export class AppModule {}

// Stricter limits for sensitive endpoints
@Throttle(10, 60) // 10 requests per minute
@Post('login')
async login() {
  // Login endpoint with stricter rate limit
}
```

## Input Sanitization

### Sanitize User Input

ALWAYS sanitize user input in addition to validation:

```typescript
// ✅ CORRECT: Input sanitization
import { Transform } from 'class-transformer';
import DOMPurify from 'isomorphic-dompurify';

export class CreateCustomerDto {
  @Transform(({ value }) => DOMPurify.sanitize(value, { ALLOWED_TAGS: [] }))
  @IsString()
  @Length(2, 200)
  companyName: string;
}
```

## Error Handling Security

### Secure Error Responses

NEVER expose stack traces or sensitive information in production:

```typescript
// ✅ CORRECT: Secure error handling
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const status = exception instanceof HttpException
      ? exception.getStatus()
      : HttpStatus.INTERNAL_SERVER_ERROR;

    // Log full error server-side
    this.logger.error({
      message: exception instanceof Error ? exception.message : 'Unknown error',
      stack: exception instanceof Error ? exception.stack : undefined,
      url: request.url,
    });

    // Return sanitized error to client
    response.status(status).json({
      statusCode: status,
      message: process.env.NODE_ENV === 'production'
        ? 'An error occurred' // Generic in production
        : exception instanceof HttpException ? exception.getResponse() : 'Internal server error',
    });
  }
}
```

## Logging Security

### Never Log Sensitive Data

```typescript
// ✅ CORRECT: Sanitized logging
logger.log('Customer created', {
  customerId: customer.id,
  userId: user.id,
  // DO NOT log: passwords, tokens, credit card numbers
});

// ❌ WRONG: Logging sensitive data
logger.log('Login attempt', {
  email: user.email,
  password: dto.password, // NEVER!
  token: jwtToken, // NEVER!
});
```

## Environment Variable Validation

### Validate Environment Variables

ALWAYS validate environment variables at startup:

```typescript
// ✅ CORRECT: Environment variable validation
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  ALLOWED_ORIGINS: z.string(),
});

export function validateEnv(): z.infer<typeof envSchema> {
  try {
    return envSchema.parse(process.env);
  } catch (error) {
    console.error('❌ Invalid environment variables:', error);
    process.exit(1);
  }
}
```

## HTTPS Enforcement

### Enforce HTTPS in Production

```typescript
// ✅ CORRECT: HTTPS enforcement
if (process.env.NODE_ENV === 'production') {
  app.use((req, res, next) => {
    if (req.header('x-forwarded-proto') !== 'https') {
      res.redirect(`https://${req.header('host')}${req.url}`);
    } else {
      next();
    }
  });
}
```

## CouchDB Security

### Database-Level Security

ALWAYS configure CouchDB _security documents:

```typescript
// ✅ CORRECT: CouchDB security configuration
const customerDbSecurity = {
  admins: {
    names: [],
    roles: ['admin', 'crm_admin'],
  },
  members: {
    names: [],
    roles: ['sales', 'crm_user'],
  },
};

await nano.db('kompass_customers').setSecurity(customerDbSecurity);
```

### Validate Functions

ALWAYS use validate functions to prevent unauthorized writes:

```typescript
// ✅ CORRECT: CouchDB validate function
const validateFunction = `
function(newDoc, oldDoc, userCtx, secObj) {
  if (newDoc.type !== 'customer') {
    throw({forbidden: 'Invalid document type'});
  }
  if (userCtx.roles.indexOf('admin') === -1 && newDoc.owner !== userCtx.name) {
    throw({forbidden: 'You can only modify your own customers'});
  }
}
`;
```

## Related Rules

- Security Best Practices: `.cursor/rules/security-best-practices.mdc` - Technical security measures
- Error Handling: `.cursor/rules/error-handling.mdc` - Secure logging patterns

## References

- RBAC Permission Matrix: `docs/reviews/RBAC_PERMISSION_MATRIX.md`
- Data Model Specification: `docs/reviews/DATA_MODEL_SPECIFICATION.md`
- Architecture Documentation: `docs/architectur/Projekt KOMPASS – Architekturdokumentation (Zielarchitektur).md`
