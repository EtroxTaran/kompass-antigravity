---
description: Performance targets, lazy loading (route-level code splitting), memoization (React.memo, useMemo, useCallback), virtual scrolling, image optimization, and bundle size monitoring
globs: ["**/*.tsx", "**/*.jsx", "**/pages/**/*.tsx", "**/components/**/*.tsx"]
alwaysApply: true
---

# Performance Optimization

## Performance Targets

From NFR_SPECIFICATION.md:

- API response P50: ≤ 400ms
- API response P95: ≤ 1.5s
- API response P99: ≤ 2.5s
- Dashboard load: ≤ 3s
- Search response: ≤ 500ms
- Offline sync (100 changes): ≤ 30s

## Lazy Loading

### Route-Level Code Splitting

ALWAYS lazy load routes:

```typescript
// ✅ CORRECT: Lazy load routes
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';
import { Skeleton } from '@/components/ui/skeleton';

const CustomerPage = lazy(() => import('./features/customer/pages/CustomerPage'));
const OpportunityPage = lazy(() => import('./features/opportunity/pages/OpportunityPage'));
const ProjectPage = lazy(() => import('./features/project/pages/ProjectPage'));

function App() {
  return (
    <Suspense fallback={<Skeleton className="h-screen w-full" />}>
      <Routes>
        <Route path="/customers" element={<CustomerPage />} />
        <Route path="/opportunities" element={<OpportunityPage />} />
        <Route path="/projects" element={<ProjectPage />} />
      </Routes>
    </Suspense>
  );
}

// ❌ WRONG: Import everything upfront
import CustomerPage from './features/customer/pages/CustomerPage';
import OpportunityPage from './features/opportunity/pages/OpportunityPage';
// This loads all pages immediately, increasing initial bundle size
```

## Memoization

### React.memo for Components

Memoize expensive components:

```typescript
// ✅ CORRECT: Memoize expensive components
import { memo } from 'react';

interface CustomerCardProps {
  customer: Customer;
  onSelect: (id: string) => void;
}

export const CustomerCard = memo(({ customer, onSelect }: CustomerCardProps) => {
  return (
    <Card onClick={() => onSelect(customer.id)}>
      <h3>{customer.companyName}</h3>
      <p>{customer.address.city}</p>
    </Card>
  );
});
```

### useMemo for Expensive Calculations

```typescript
// ✅ CORRECT: Memoize expensive calculations
import { useMemo } from 'react';

function CustomerDashboard({ customers }: { customers: Customer[] }) {
  // Expensive calculation - only recompute when customers change
  const statistics = useMemo(() => {
    return {
      total: customers.length,
      totalRevenue: customers.reduce((sum, c) => sum + (c.totalRevenue || 0), 0),
      averageRevenue: customers.length > 0 
        ? customers.reduce((sum, c) => sum + (c.totalRevenue || 0), 0) / customers.length 
        : 0,
      byRating: {
        A: customers.filter(c => c.rating === 'A').length,
        B: customers.filter(c => c.rating === 'B').length,
        C: customers.filter(c => c.rating === 'C').length,
      },
    };
  }, [customers]);

  return <Dashboard statistics={statistics} />;
}
```

### useCallback for Function References

```typescript
// ✅ CORRECT: Memoize callback functions
import { useCallback } from 'react';

function CustomerList({ customers }: { customers: Customer[] }) {
  const handleSelect = useCallback((customerId: string) => {
    // This function reference is stable across renders
    navigate(`/customers/${customerId}`);
  }, []); // Empty deps = function never changes

  return customers.map(customer => (
    <CustomerCard 
      key={customer.id} 
      customer={customer} 
      onSelect={handleSelect} // Stable reference
    />
  ));
}
```

## Virtual Scrolling

### Virtual Lists for Large Data

Use virtual scrolling for lists with >100 items:

```typescript
// ✅ CORRECT: Virtual scrolling for >100 items
import { useVirtualizer } from '@tanstack/react-virtual';

function CustomerList({ customers }: { customers: Customer[] }) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: customers.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 100, // Estimated row height
  });

  return (
    <div ref={parentRef} style={{ height: '600px', overflow: 'auto' }}>
      <div style={{ height: `${virtualizer.getTotalSize()}px`, position: 'relative' }}>
        {virtualizer.getVirtualItems().map(virtualItem => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            <CustomerCard customer={customers[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Image Optimization

### WebP Format and Lazy Loading

```typescript
// ✅ CORRECT: Optimized images
<picture>
  <source srcSet="/images/customer-logo.webp" type="image/webp" />
  <source srcSet="/images/customer-logo.jpg" type="image/jpeg" />
  <img 
    src="/images/customer-logo.jpg" 
    alt="Customer Logo"
    loading="lazy"  // Native lazy loading
    width={200}
    height={200}
  />
</picture>

// ❌ WRONG: Unoptimized images
<img src="/images/customer-logo.png" /> // Large PNG, no lazy loading
```

## Bundle Size Monitoring

### Bundle Analysis

```json
// package.json scripts
{
  "scripts": {
    "analyze": "vite-bundle-visualizer",
    "build:analyze": "pnpm build && pnpm analyze"
  }
}

// Alert if any chunk exceeds 500KB
// Use dynamic imports to split large chunks
```

### Code Splitting Best Practices

```typescript
// ✅ CORRECT: Dynamic imports for large dependencies
const HeavyComponent = lazy(() => import('./HeavyComponent'));

// ✅ CORRECT: Split vendor chunks
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'ui-vendor': ['@radix-ui/react-dialog', '@radix-ui/react-select'],
        },
      },
    },
  },
});
```

## API Performance

### Caching Strategies

```typescript
// ✅ CORRECT: React Query caching
import { useQuery } from '@tanstack/react-query';

export function useCustomer(id: string) {
  return useQuery({
    queryKey: ['customer', id],
    queryFn: () => customerApi.getById(id),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  });
}
```

### Database Query Optimization

```typescript
// ✅ CORRECT: Optimized database queries
async findAll(filters: CustomerFilters): Promise<Customer[]> {
  // Use CouchDB Mango queries with indexes
  const query = {
    selector: {
      type: 'customer',
      ...filters,
    },
    limit: 100,
    sort: [{ companyName: 'asc' }],
    use_index: 'customer-company-name-index',
  };

  return this.repository.find(query);
}
```

## References

- NFR Specification: `docs/reviews/NFR_SPECIFICATION.md`
- Architecture Documentation: `docs/architectur/Projekt KOMPASS – Architekturdokumentation (Zielarchitektur).md`
