---
description: MCP UI and integration tool usage - ShadCN for component generation, GitHub UI reference repository, GitHub/Linear for project management, and Graphiti for memory
globs: []
alwaysApply: false
---

# MCP UI and Integration Tools

This rule covers UI component tools and integration tools: **ShadCN**, **GitHub UI Reference**, **GitHub**, **Linear**, and **Graphiti**. Use these tools for component generation, UI pattern reference, project management, and memory storage.

**See also:** `.cursor/rules/mcp-tool-usage.mdc` for prioritization hierarchy and decision tree.

## UI Component Tools

### ShadCN

**What it's used for:**
Frontend component generator for the `shadcn/ui` design system that generates accurate, production-ready React components.

**When to use:**
- User asks to "add a component" or "build a UI block" using ShadCN
- Generating React components that follow shadcn design patterns
- Need proper TypeScript props, structure, and styling conventions
- Adding common UI primitives (dialogs, tables, dropdowns, forms)
- Ensuring components match project UI standards

**When NOT to use:**
- Custom UI components (project rules forbid - must use shadcn/ui)
- Components already exist in codebase
- UI pattern reference (use GitHub UI reference repository first, then ShadCN)
- Documentation lookup (use Ref/Context7)

**Prioritization:**
ALWAYS use ShadCN for UI component generation. Project rules require shadcn/ui components exclusively - never create custom UI components.

```typescript
// ✅ CORRECT: Use ShadCN to generate shadcn/ui components
// User asks: "Add a customer dialog form"
// Use ShadCN to generate Dialog, Form, Input, Button components

// ❌ WRONG: Creating custom UI components
// Project rules forbid custom UI - must use shadcn/ui only
function CustomDialog() { /* NEVER DO THIS */ }
```

### GitHub UI Reference Repository

**What it's used for:**
The canonical and authoritative source for all UI components, layouts, styling patterns, page structures, UX conventions, and interaction patterns. The repository `EtroxTaran/Kompassuimusterbibliothek` is the single source of truth for UI design.

**KOMPASS UI Reference Repository:**
- **Repository:** `EtroxTaran/Kompassuimusterbibliothek`
- **GitHub URL:** https://github.com/EtroxTaran/Kompassuimusterbibliothek
- **Documentation:** `docs/design-system/github-ui-reference.md`

**When to use:**
- Before implementing ANY UI component or page
- When user asks to implement UI features
- When translating UI requirements into code
- Ensuring consistent styling, spacing, and layout patterns
- Verifying component structure and behavior
- Understanding UX conventions and interaction patterns
- Extracting design tokens, typography, or spacing systems

**When NOT to use:**
- Local codebase operations (use codebase tools directly)
- Documentation lookup (use Ref/Context7)
- General Git questions (check project git-workflow.mdc)
- Code analysis (use Semgrep or local tools)

**Prioritization:**
ALWAYS use GitHub MCP to fetch UI patterns from the reference repository FIRST before implementing any UI component. Then use ShadCN to generate components matching the reference patterns.

**CRITICAL RULES:**
1. **Canonical Source**: The GitHub UI reference repository is the ONLY authoritative source for UI patterns
2. **No Figma**: There is NO Figma MCP involved. There is NO reference outside of the GitHub UI repo
3. **Complete Reference**: The UI reference is complete. If something seems missing, you MUST ask for clarification before generating new UI patterns
4. **Mirror Patterns**: Everything you create MUST mirror, extend, or adapt patterns from that repo
5. **No Invention**: Do NOT invent new UI patterns unless explicitly requested
6. **Ask When Uncertain**: If a required element seems missing, pause and ask the user

**Workflow:**
1. **Fetch from Reference**: Use GitHub MCP to fetch files from `EtroxTaran/Kompassuimusterbibliothek`
2. **Inspect Patterns**: Read component source code, layout structures, styling conventions
3. **Mirror/Adapt**: Rebuild using our stack (React + shadcn/ui + Tailwind) matching reference patterns
4. **Generate Components**: Use ShadCN to generate components matching reference structure
5. **Verify Compliance**: Ensure implementation matches reference patterns precisely

```typescript
// ✅ CORRECT: Use GitHub MCP to fetch UI patterns, then ShadCN for components
// Step 1: Fetch component from GitHub UI reference repository
// Step 2: Inspect structure, props, patterns, naming, logic
// Step 3: Rebuild using shadcn/ui matching reference patterns
// Step 4: Apply extracted spacing, colors, typography from reference

// ❌ WRONG: Generating components without checking reference repository
// Always fetch UI patterns from GitHub reference repo first
// Never invent new UI patterns without checking reference
```

## Integration Tools

### GitHub

**What it's used for:**
Integration for GitHub repositories and their metadata, including file contents, commits, issue threads, PR comments, or CI statuses. **CRITICAL**: Also used to fetch UI patterns from the canonical UI reference repository `EtroxTaran/Kompassuimusterbibliothek`.

**When to use:**
- **UI Reference**: Fetching UI components, layouts, and patterns from `EtroxTaran/Kompassuimusterbibliothek` (ALWAYS do this before implementing UI)
- Pulling file contents, commits, or PR data from external repositories
- Understanding the structure of an external repository or specific files
- Inspecting component source code, layout structures, styling conventions from UI reference
- Automating issue or pull request creation or interaction
- Retrieving GitHub Actions CI/CD status
- Accessing GitHub API for repository metadata

**When NOT to use:**
- Local codebase operations (use codebase tools directly)
- Documentation lookup (use Ref/Context7)
- General Git questions (check project git-workflow.mdc)
- Code analysis (use Semgrep or local tools)

**Prioritization:**
Use GitHub MCP tool for external repository operations, especially for fetching UI patterns from the reference repository. For local repository, use standard Git commands or Cursor's built-in Git features.

**UI Reference Workflow:**
1. Use GitHub MCP to list directories in `EtroxTaran/Kompassuimusterbibliothek`
2. Identify matching components/pages in the reference repo
3. Read relevant files to understand structure, props, patterns, naming, logic
4. Mirror/adapt patterns into the new project using shadcn/ui

**CRITICAL: Verification Before Creating PRs**

**NEVER create a pull request via GitHub MCP without running ALL verification checks first.**

Before creating ANY pull request (even via GitHub MCP), you MUST:

1. **Run Full Verification**
   ```bash
   ./scripts/verify-code.sh
   # OR
   pnpm format:check && pnpm lint && pnpm type-check && pnpm test:unit
   ```

2. **Show Verification Results**
   - Show actual command outputs
   - Verify all checks passed
   - Fix any failures before creating PR

3. **Include Verification in PR Description**
   - Add verification summary to PR body
   - Show what checks were run and their results

**✅ CORRECT: Creating PR via GitHub MCP**
```bash
# Step 1: Run verification
$ ./scripts/verify-code.sh
✅ ALL VERIFICATION CHECKS PASSED

# Step 2: Show results
Verification:
- ✅ Format check passed
- ✅ Lint check passed
- ✅ Type check passed
- ✅ Unit tests passed

# Step 3: Create PR with verification summary
# PR description includes verification results
```

**❌ WRONG: Creating PR Without Verification**
```bash
# ❌ Creating PR via GitHub MCP without running checks
# No verification, no checks, just creating PR
```

See `.cursor/rules/ai-code-verification.mdc` for complete verification requirements.

```typescript
// ✅ CORRECT: Use GitHub MCP for external repository access
// User asks: "Get the latest version of a library from GitHub"
// Use GitHub MCP to fetch file from external repository

// ❌ WRONG: Using GitHub MCP for local repository
// Use local file system tools for codebase operations
```

### Linear

**What it's used for:**
Project management tool integration for retrieving or updating project issues, feature requests, bug reports, or tasks.

**When to use:**
- Retrieve Linear issues for context
- Update issue status after completing work
- Link code changes to Linear issues
- Create new issues for bugs or features
- Get issue details, comments, or assignees
- Search for related issues

**When NOT to use:**
- Commit message format (covered in linear-integration.mdc)
- Branch naming (covered in linear-integration.mdc)
- General project questions (check project documentation)

**Prioritization:**
Use Linear MCP tool when actively working on issues or need issue context. Always link commits and PRs to Linear issues as per project rules.

```typescript
// ✅ CORRECT: Use Linear to retrieve issue context
// Before starting work on KOM-123, use Linear to get issue details
// After completing work, update Linear issue status to "Done"

// ❌ WRONG: Working on code without checking Linear issue
// Always reference Linear issues in commits and PRs
```

### Graphiti

**What it's used for:**
Persistent, project-scoped long-term memory for storing architectural decisions, infrastructure changes, routing updates, refactors, and bug fixes.

**When to use:**
- Storing architectural decisions and ADR context
- Documenting Docker and container infrastructure changes
- Recording routing and navigation updates
- Saving important implementation patterns and refactors
- Documenting non-trivial bugs and fixes

**When NOT to use:**
- Temporary information (don't clutter memory)
- Code that's self-explanatory
- Information already in ADRs or documentation
- General knowledge (use Perplexity)

**Prioritization:**
ALWAYS check Graphiti memory FIRST before answering questions or making decisions. Store significant decisions and patterns in Graphiti for future reference.

**Note:** Detailed Graphiti usage rules are in `.cursor/rules/graphiti-memory.mdc`. Always refer to that file for specific storage requirements.

```typescript
// ✅ CORRECT: Check Graphiti before making architectural decisions
// Step 1: Search Graphiti for previous decisions
// Step 2: If not found, make decision and store in Graphiti
// Step 3: Reference Graphiti memory in future similar decisions

// ❌ WRONG: Making decisions without checking Graphiti memory
// Always check stored context before deciding on architecture
```

## Tool Integration Workflow

### Design to Code Flow

1. **GitHub UI Reference** → Fetch UI patterns from reference repository (components, layouts, styling)
2. **ShadCN** → Generate components matching reference patterns
3. **Project Rules** → Verify compliance with UI component standards

### Issue to Code Flow

1. **Linear** → Retrieve issue details and requirements
2. **Graphiti** → Check for related architectural decisions
3. **Code Generation** → Use Cursor AI with context
4. **Linear** → Update issue status after completion

### External Reference Flow

1. **GitHub** → Fetch external library or reference code
2. **Ref/Context7** → Lookup library documentation
3. **Codebase** → Integrate with project code

## References

- Main MCP Tool Usage: `.cursor/rules/mcp-tool-usage.mdc`
- Graphiti Memory: `.cursor/rules/graphiti-memory.mdc`
- Linear Integration: `.cursor/rules/linear-integration.mdc`
- UI Components: `.cursor/rules/ui-components.mdc`
- Git Workflow: `.cursor/rules/git-workflow.mdc`
