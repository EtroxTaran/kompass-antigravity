---
description: "Nested REST API patterns for parent-child resource relationships (e.g., Location under Customer, Contacts under Customer)"
globs: []
alwaysApply: true
---

# Nested REST Resource Patterns

## Overview

KOMPASS uses nested REST API patterns for parent-child resource relationships where one resource conceptually "belongs to" another. This pattern provides clear data ownership and simplifies permission checking.

## Nested Resource URL Structure

### Pattern

```
/api/v1/{parentResource}/{parentId}/{childResource}
/api/v1/{parentResource}/{parentId}/{childResource}/{childId}
```

### Examples

```
POST   /api/v1/customers/{customerId}/locations
GET    /api/v1/customers/{customerId}/locations
GET    /api/v1/customers/{customerId}/locations/{locationId}
PUT    /api/v1/customers/{customerId}/locations/{locationId}
DELETE /api/v1/customers/{customerId}/locations/{locationId}

GET    /api/v1/contacts/{contactId}/decision-authority
PUT    /api/v1/contacts/{contactId}/decision-authority
```

## Controller Implementation

### Nested Resource Controller

```typescript
// ✅ CORRECT: Nested REST routes under parent resource
@Controller('api/v1/customers/:customerId/locations')
@ApiTags('Locations')
@ApiBearerAuth()
@UseGuards(JwtAuthGuard, RbacGuard)
export class LocationController {
  constructor(private readonly locationService: LocationService) {}

  @Post()
  @RequirePermission('Location', 'CREATE')
  async createLocation(
    @Param('customerId') customerId: string,
    @Body() dto: CreateLocationDto,
    @CurrentUser() user: User,
  ): Promise<LocationResponseDto> {
    // Service validates customer exists and user has access
    return this.locationService.create(customerId, dto, user);
  }

  @Get()
  @RequirePermission('Location', 'READ')
  async listLocations(
    @Param('customerId') customerId: string,
    @CurrentUser() user: User,
  ): Promise<LocationResponseDto[]> {
    return this.locationService.findByCustomer(customerId, user);
  }

  @Get(':locationId')
  @RequirePermission('Location', 'READ')
  async getLocation(
    @Param('customerId') customerId: string,
    @Param('locationId') locationId: string,
    @CurrentUser() user: User,
  ): Promise<LocationResponseDto> {
    return this.locationService.findOne(customerId, locationId, user);
  }
}

// ❌ WRONG: Top-level routes for child resource
@Controller('api/v1/locations')
export class LocationController {
  // Missing parent context - violates data ownership model
}
```

## Service Layer Parent Validation

### ALWAYS Validate Parent Exists

```typescript
// ✅ CORRECT: Validate parent customer exists and user has access
async create(
  customerId: string,
  dto: CreateLocationDto,
  user: User,
): Promise<LocationResponseDto> {
  // Check if user can access parent customer
  const customer = await this.customerService.findById(customerId, user);
  if (!customer) {
    throw new NotFoundException(`Customer ${customerId} not found`);
  }

  // RBAC: ADM can only create locations for their own customers
  if (user.role === 'ADM' && customer.owner !== user.id) {
    throw new ForbiddenException('You can only create locations for your own customers');
  }

  // Create location
  const location = createLocation({ ...dto, customerId }, user.id);
  return await this.locationRepository.create(location);
}

// ❌ WRONG: No parent validation
async create(customerId: string, dto: CreateLocationDto): Promise<Location> {
  // Missing parent validation - security risk!
  return await this.locationRepository.create({ ...dto, customerId });
}
```

### Verify Child Belongs to Parent

```typescript
// ✅ CORRECT: Verify location belongs to customer
async findOne(
  customerId: string,
  locationId: string,
  user: User,
): Promise<LocationResponseDto> {
  // Verify customer access
  await this.customerService.findById(customerId, user);

  // Get location
  const location = await this.locationRepository.findById(locationId);
  
  if (!location) {
    throw new NotFoundException(`Location ${locationId} not found`);
  }

  // Verify location belongs to customer
  if (location.customerId !== customerId) {
    throw new NotFoundException(`Location ${locationId} not found for customer ${customerId}`);
  }

  return this.mapToResponseDto(location);
}
```

## Query Scoping for Nested Resources

### Parent-Scoped Queries

```typescript
// ✅ CORRECT: Query scoped to parent
async findByCustomer(customerId: string): Promise<Location[]> {
  return await this.db.find({
    selector: {
      type: 'location',
      customerId: customerId, // Parent scope
    },
    limit: 1000,
  });
}

// ❌ WRONG: Global query without parent scope
async findAll(): Promise<Location[]> {
  return await this.db.find({
    selector: { type: 'location' }, // Missing parent scope
  });
}
```

## RBAC Cascading for Nested Entities

### Record-Level Permissions Cascade

```typescript
// ✅ CORRECT: RBAC cascades from parent to child
async create(customerId: string, dto: CreateLocationDto, user: User): Promise<Location> {
  const customer = await this.customerService.findById(customerId, user);

  // Parent permission check: ADM can only access own customers
  if (user.role === 'ADM' && customer.owner !== user.id) {
    throw new ForbiddenException('You can only create locations for your own customers');
  }

  // If parent access is granted, child creation is allowed
  // (assuming entity-level permission 'Location.CREATE' is granted)
  return await this.locationRepository.create({ ...dto, customerId });
}

// Child inherits parent's access control:
// - ADM who owns customer can manage customer's locations
// - PLAN/GF can manage all customers' locations
```

## Filtering Nested Resources

### Query Parameters for Nested Lists

```typescript
// ✅ CORRECT: Filter query params
@Get()
async listLocations(
  @Param('customerId') customerId: string,
  @Query('locationType') locationType?: LocationType,
  @Query('isActive') isActive?: boolean,
  @Query('sort') sort: string = 'locationName',
  @Query('order') order: 'asc' | 'desc' = 'asc',
  @CurrentUser() user?: User,
): Promise<LocationResponseDto[]> {
  let locations = await this.locationService.findByCustomer(customerId, user);

  // Apply filters
  if (locationType) {
    locations = locations.filter((loc) => loc.locationType === locationType);
  }

  if (isActive !== undefined) {
    locations = locations.filter((loc) => loc.isActive === isActive);
  }

  // Apply sorting
  locations.sort((a, b) => {
    const aVal = a[sort] || '';
    const bVal = b[sort] || '';
    return order === 'asc' ? (aVal > bVal ? 1 : -1) : (aVal < bVal ? 1 : -1);
  });

  return locations;
}
```

## Business Rules for Nested Resources

### Parent-Child Constraints

```typescript
// ✅ CORRECT: Enforce business rule - location name unique within customer
async create(customerId: string, dto: CreateLocationDto, user: User): Promise<Location> {
  // Check uniqueness within parent scope
  const existingLocation = await this.locationRepository.findByCustomerAndName(
    customerId,
    dto.locationName,
  );

  if (existingLocation) {
    throw new ConflictException(
      `Location name "${dto.locationName}" already exists for this customer`,
    );
  }

  return await this.locationRepository.create({ ...dto, customerId });
}

// Business rule: Cannot delete location if in use by projects/quotes
async delete(customerId: string, locationId: string, user: User): Promise<void> {
  const inUse = await this.locationRepository.isLocationInUse(locationId);
  if (inUse) {
    throw new ConflictException(
      'Cannot delete location: it is referenced in active projects or quotes',
    );
  }

  await this.locationRepository.delete(locationId);
}
```

## Frontend API Client Pattern

### Nested Resource API

```typescript
// ✅ CORRECT: Nested API client
export const locationApi = {
  async getLocations(customerId: string): Promise<Location[]> {
    const response = await axios.get(
      `${API_BASE_URL}/api/v1/customers/${customerId}/locations`
    );
    return response.data;
  },

  async getLocation(customerId: string, locationId: string): Promise<Location> {
    const response = await axios.get(
      `${API_BASE_URL}/api/v1/customers/${customerId}/locations/${locationId}`
    );
    return response.data;
  },

  async createLocation(customerId: string, data: CreateLocationRequest): Promise<Location> {
    const response = await axios.post(
      `${API_BASE_URL}/api/v1/customers/${customerId}/locations`,
      data
    );
    return response.data;
  },
};
```

## Examples

### Location under Customer

**URL Structure:**
- `POST /api/v1/customers/{customerId}/locations` - Create location
- `GET /api/v1/customers/{customerId}/locations` - List customer's locations
- `GET /api/v1/customers/{customerId}/locations/{locationId}` - Get specific location
- `PUT /api/v1/customers/{customerId}/locations/{locationId}` - Update location
- `DELETE /api/v1/customers/{customerId}/locations/{locationId}` - Delete location

**Business Rules:**
- Location name must be unique within customer (not globally)
- ADM can only manage locations for their own customers
- PLAN/GF can manage all locations
- Cannot delete location if referenced in projects/quotes

### Contact Decision Authority under Contact

**URL Structure:**
- `GET /api/v1/contacts/{contactId}/decision-authority` - Get decision authority
- `PUT /api/v1/contacts/{contactId}/decision-authority` - Update decision authority

**Business Rules:**
- Only PLAN and GF can update decision authority
- All roles can view decision authority
- Approval limit required if canApproveOrders=true

## References

- API Specification: `docs/reviews/API_SPECIFICATION.md`
- RBAC Permission Matrix: `docs/reviews/RBAC_PERMISSION_MATRIX.md`
- Location Entity: `packages/shared/src/types/entities/location.ts`
