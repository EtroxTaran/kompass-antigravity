# KOMPASS Docker Compose - Staging Environment
# Override for staging-specific configuration
# Integrates with existing Traefik on proxynet network

services:
  couchdb:
    environment:
      - COUCHDB_USER=${STAGING_COUCHDB_USER}
      - COUCHDB_PASSWORD=${STAGING_COUCHDB_PASSWORD}
    volumes:
      - /opt/kompass/staging/data/couchdb:/opt/couchdb/data
      - /opt/kompass/staging/config/couchdb:/opt/couchdb/etc/local.d
    networks:
      - proxynet
    restart: always
    # Internal service - no Traefik labels, no ports exposed

  meilisearch:
    environment:
      - MEILI_MASTER_KEY=${STAGING_MEILI_MASTER_KEY}
      - MEILI_ENV=production
    volumes:
      - /opt/kompass/staging/data/meilisearch:/meili_data
    networks:
      - proxynet
    restart: always
    # Internal service - no Traefik labels, no ports exposed

  postgres:
    image: postgres:16-alpine
    container_name: kompass-postgres
    environment:
      - POSTGRES_DB=keycloak
      - POSTGRES_USER=${STAGING_POSTGRES_USER:-keycloak}
      - POSTGRES_PASSWORD=${STAGING_POSTGRES_PASSWORD:-changeme}
      - PGDATA=/var/lib/postgresql/data/pgdata
    volumes:
      - /opt/kompass/staging/data/postgres:/var/lib/postgresql/data
    networks:
      - proxynet
    restart: always
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U ${STAGING_POSTGRES_USER:-keycloak}']
      interval: 10s
      timeout: 5s
      retries: 5
    # Internal service - no Traefik labels, no ports exposed

  keycloak:
    environment:
      - KEYCLOAK_ADMIN=${STAGING_KEYCLOAK_ADMIN:-admin}
      - KEYCLOAK_ADMIN_PASSWORD=${STAGING_KEYCLOAK_ADMIN_PASSWORD:-stagingpassword}
      - KC_DB=postgres
      - KC_DB_URL=jdbc:postgresql://postgres:5432/keycloak
      - KC_DB_USERNAME=${STAGING_POSTGRES_USER:-keycloak}
      - KC_DB_PASSWORD=${STAGING_POSTGRES_PASSWORD:-changeme}
      - KC_HTTP_ENABLED=true
      - KC_HOSTNAME_STRICT=false
      - KC_HOSTNAME_STRICT_HTTPS=false
      - KC_LOG_LEVEL=info
      - KC_HEALTH_ENABLED=true
    command:
      - start-dev
    # Override ports from base docker-compose.yml - remove host port mapping
    # Keycloak is internal-only, accessed via http://keycloak:8080 by backend
    ports: []
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - proxynet
    healthcheck:
      # Simple TCP connection test - check if port 8080 is listening
      # This works without requiring curl/wget/pgrep
      test: ['CMD-SHELL', 'timeout 1 bash -c "</dev/tcp/localhost/8080" 2>/dev/null || exit 1']
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 120s  # Keycloak takes longer to start with PostgreSQL and schema initialization
    restart: always
    # Internal service - accessed via http://keycloak:8080 by backend
    # No Traefik labels - not exposed publicly

  neo4j:
    environment:
      - NEO4J_AUTH=${STAGING_NEO4J_AUTH:-neo4j/stagingpassword}
    volumes:
      - /opt/kompass/staging/data/neo4j:/data
      - /opt/kompass/staging/logs/neo4j:/logs
    networks:
      - proxynet
    restart: always
    # Internal service - no Traefik labels, no ports exposed

  # whisper:
  #   # Staging uses an external Whisper API (e.g. OpenAI) instead of a local container.
  #   # The backend connects via WHISPER_API_URL provided by STAGING_WHISPER_API_URL.
  #   # If you want to self-host Whisper in staging in the future, replace this with
  #   # an ARM64-compatible image or run Whisper on a dedicated x86_64+GPU host and
  #   # point WHISPER_API_URL to that internal endpoint.
  #   environment:
  #     - ASR_MODEL=${STAGING_WHISPER_MODEL:-base}
  #   volumes:
  #     - /opt/kompass/staging/data/whisper:/root/.cache/whisper
  #   networks:
  #     - proxynet
  #   restart: always
  #   # Internal service - no Traefik labels, no ports exposed

  n8n:
    environment:
      - N8N_BASIC_AUTH_ACTIVE=${STAGING_N8N_BASIC_AUTH_ACTIVE:-true}
      - N8N_BASIC_AUTH_USER=${STAGING_N8N_BASIC_AUTH_USER:-admin}
      - N8N_BASIC_AUTH_PASSWORD=${STAGING_N8N_BASIC_AUTH_PASSWORD:-changeme}
      - N8N_HOST=${STAGING_N8N_HOST:-n8n.kompass.etrox.de}
      - N8N_PROTOCOL=https
      - WEBHOOK_URL=${STAGING_N8N_WEBHOOK_URL:-http://n8n:5678}
    volumes:
      - /opt/kompass/staging/data/n8n:/home/node/.n8n
    networks:
      - proxynet
    restart: always
    # Internal service - accessed via http://n8n:5678 by backend
    # No Traefik labels - not exposed publicly
    # Note: If webhooks need external access, add Traefik labels with Host(`n8n.kompass.etrox.de`)

  backend:
    # Override build section from base docker-compose.yml - staging uses pre-built images
    # Using empty object to remove build context requirement
    build: {}
    image: ghcr.io/${GITHUB_REPOSITORY}/backend:${IMAGE_TAG:-staging}
    environment:
      - NODE_ENV=production
      - PORT=3000
      # CouchDB connection (DatabaseModule expects these variable names)
      - COUCHDB_URL=${STAGING_COUCHDB_URL:-${STAGING_DATABASE_URL:-http://couchdb:5984}}
      - COUCHDB_ADMIN_USER=${STAGING_COUCHDB_ADMIN_USER:-${STAGING_COUCHDB_USER:-admin}}
      - COUCHDB_ADMIN_PASSWORD=${STAGING_COUCHDB_ADMIN_PASSWORD:-${STAGING_COUCHDB_PASSWORD}}
      - COUCHDB_DATABASE=${STAGING_COUCHDB_DATABASE:-kompass_staging}
      # Legacy variable names (for backward compatibility)
      - DATABASE_URL=${STAGING_DATABASE_URL:-http://couchdb:5984}
      - COUCHDB_USER=${STAGING_COUCHDB_USER}
      - COUCHDB_PASSWORD=${STAGING_COUCHDB_PASSWORD}
      - MEILISEARCH_URL=${STAGING_MEILISEARCH_URL}
      - MEILISEARCH_MASTER_KEY=${STAGING_MEILI_MASTER_KEY}
      - KEYCLOAK_URL=${STAGING_KEYCLOAK_URL:-http://keycloak:8080}
      - KEYCLOAK_REALM=kompass-staging
      - KEYCLOAK_CLIENT_ID=kompass-api-staging
      - KEYCLOAK_CLIENT_SECRET=${STAGING_KEYCLOAK_CLIENT_SECRET}
      - JWT_SECRET=${STAGING_JWT_SECRET}
      - ALLOWED_ORIGINS=${STAGING_ALLOWED_ORIGINS:-https://kompass.etrox.de}
      - LOG_LEVEL=info
      # Neo4j connection
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=${STAGING_NEO4J_PASSWORD:-stagingpassword}
      # Whisper API
      - WHISPER_API_URL=${STAGING_WHISPER_API_URL:-http://whisper:9000}
      # n8n webhook URL (internal access)
      - N8N_WEBHOOK_URL=${STAGING_N8N_WEBHOOK_URL:-http://n8n:5678}
      # Feature flags (injected from GitHub Secrets)
      - AI_N8N_ENABLED=${STAGING_AI_N8N_ENABLED:-false}
      - AI_RAG_ENABLED=${STAGING_AI_RAG_ENABLED:-false}
      - AI_ML_ENABLED=${STAGING_AI_ML_ENABLED:-false}
    networks:
      - proxynet
    restart: always
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'
    labels:
      - 'traefik.enable=true'
      - 'traefik.http.routers.backend.rule=Host(`api.kompass.etrox.de`)'
      - 'traefik.http.routers.backend.entrypoints=https'
      - 'traefik.http.routers.backend.tls=true'
      - 'traefik.http.routers.backend.tls.certresolver=production'
      - 'traefik.http.services.backend.loadbalancer.server.port=3000'

  frontend:
    # Override build section from base docker-compose.yml - staging uses pre-built images
    # Using empty object to remove build context requirement
    build: {}
    image: ghcr.io/${GITHUB_REPOSITORY}/frontend:${IMAGE_TAG:-staging}
    environment:
      - VITE_API_URL=${STAGING_API_URL:-https://api.kompass.etrox.de}
      # Feature flags (for frontend feature toggles)
      - VITE_AI_N8N_ENABLED=${STAGING_AI_N8N_ENABLED:-false}
      - VITE_AI_RAG_ENABLED=${STAGING_AI_RAG_ENABLED:-false}
      - VITE_AI_ML_ENABLED=${STAGING_AI_ML_ENABLED:-false}
    networks:
      - proxynet
    restart: always
    logging:
      driver: 'json-file'
      options:
        max-size: '10m'
        max-file: '3'
    labels:
      - 'traefik.enable=true'
      - 'traefik.http.routers.frontend.rule=Host(`kompass.etrox.de`)'
      - 'traefik.http.routers.frontend.entrypoints=https'
      - 'traefik.http.routers.frontend.tls=true'
      - 'traefik.http.routers.frontend.tls.certresolver=production'
      - 'traefik.http.services.frontend.loadbalancer.server.port=8080'

networks:
  proxynet:
    external: true
# Note: All services use bind mounts (host paths) instead of named volumes
# This allows better control over data persistence and backup strategies
# No named volumes needed - removed to avoid orphaned volume definitions
